"use strict"; (self.webpackChunkrock_paper_scissors = self.webpackChunkrock_paper_scissors || []).push([[179], { 54: () => { function X(e) { return "function" == typeof e } function Ur(e) { const n = e(r => { Error.call(r), r.stack = (new Error).stack }); return n.prototype = Object.create(Error.prototype), n.prototype.constructor = n, n } const ti = Ur(e => function (n) { e(this), this.message = n ? `${n.length} errors occurred during unsubscription:\n${n.map((r, o) => `${o + 1}) ${r.toString()}`).join("\n  ")}` : "", this.name = "UnsubscriptionError", this.errors = n }); function Br(e, t) { if (e) { const n = e.indexOf(t); 0 <= n && e.splice(n, 1) } } class it { constructor(t) { this.initialTeardown = t, this.closed = !1, this._parentage = null, this._finalizers = null } unsubscribe() { let t; if (!this.closed) { this.closed = !0; const { _parentage: n } = this; if (n) if (this._parentage = null, Array.isArray(n)) for (const i of n) i.remove(this); else n.remove(this); const { initialTeardown: r } = this; if (X(r)) try { r() } catch (i) { t = i instanceof ti ? i.errors : [i] } const { _finalizers: o } = this; if (o) { this._finalizers = null; for (const i of o) try { Kc(i) } catch (s) { t = t ?? [], s instanceof ti ? t = [...t, ...s.errors] : t.push(s) } } if (t) throw new ti(t) } } add(t) { var n; if (t && t !== this) if (this.closed) Kc(t); else { if (t instanceof it) { if (t.closed || t._hasParent(this)) return; t._addParent(this) } (this._finalizers = null !== (n = this._finalizers) && void 0 !== n ? n : []).push(t) } } _hasParent(t) { const { _parentage: n } = this; return n === t || Array.isArray(n) && n.includes(t) } _addParent(t) { const { _parentage: n } = this; this._parentage = Array.isArray(n) ? (n.push(t), n) : n ? [n, t] : t } _removeParent(t) { const { _parentage: n } = this; n === t ? this._parentage = null : Array.isArray(n) && Br(n, t) } remove(t) { const { _finalizers: n } = this; n && Br(n, t), t instanceof it && t._removeParent(this) } } it.EMPTY = (() => { const e = new it; return e.closed = !0, e })(); const Yc = it.EMPTY; function Qc(e) { return e instanceof it || e && "closed" in e && X(e.remove) && X(e.add) && X(e.unsubscribe) } function Kc(e) { X(e) ? e() : e.unsubscribe() } const Cn = { onUnhandledError: null, onStoppedNotification: null, Promise: void 0, useDeprecatedSynchronousErrorHandling: !1, useDeprecatedNextContext: !1 }, ni = { setTimeout(e, t, ...n) { const { delegate: r } = ni; return r?.setTimeout ? r.setTimeout(e, t, ...n) : setTimeout(e, t, ...n) }, clearTimeout(e) { const { delegate: t } = ni; return (t?.clearTimeout || clearTimeout)(e) }, delegate: void 0 }; function Xc(e) { ni.setTimeout(() => { const { onUnhandledError: t } = Cn; if (!t) throw e; t(e) }) } function Jc() { } const vD = ia("C", void 0, void 0); function ia(e, t, n) { return { kind: e, value: t, error: n } } let _n = null; function ri(e) { if (Cn.useDeprecatedSynchronousErrorHandling) { const t = !_n; if (t && (_n = { errorThrown: !1, error: null }), e(), t) { const { errorThrown: n, error: r } = _n; if (_n = null, n) throw r } } else e() } class sa extends it { constructor(t) { super(), this.isStopped = !1, t ? (this.destination = t, Qc(t) && t.add(this)) : this.destination = SD } static create(t, n, r) { return new Hr(t, n, r) } next(t) { this.isStopped ? ua(function wD(e) { return ia("N", e, void 0) }(t), this) : this._next(t) } error(t) { this.isStopped ? ua(function DD(e) { return ia("E", void 0, e) }(t), this) : (this.isStopped = !0, this._error(t)) } complete() { this.isStopped ? ua(vD, this) : (this.isStopped = !0, this._complete()) } unsubscribe() { this.closed || (this.isStopped = !0, super.unsubscribe(), this.destination = null) } _next(t) { this.destination.next(t) } _error(t) { try { this.destination.error(t) } finally { this.unsubscribe() } } _complete() { try { this.destination.complete() } finally { this.unsubscribe() } } } const _D = Function.prototype.bind; function aa(e, t) { return _D.call(e, t) } class ED { constructor(t) { this.partialObserver = t } next(t) { const { partialObserver: n } = this; if (n.next) try { n.next(t) } catch (r) { oi(r) } } error(t) { const { partialObserver: n } = this; if (n.error) try { n.error(t) } catch (r) { oi(r) } else oi(t) } complete() { const { partialObserver: t } = this; if (t.complete) try { t.complete() } catch (n) { oi(n) } } } class Hr extends sa { constructor(t, n, r) { let o; if (super(), X(t) || !t) o = { next: t ?? void 0, error: n ?? void 0, complete: r ?? void 0 }; else { let i; this && Cn.useDeprecatedNextContext ? (i = Object.create(t), i.unsubscribe = () => this.unsubscribe(), o = { next: t.next && aa(t.next, i), error: t.error && aa(t.error, i), complete: t.complete && aa(t.complete, i) }) : o = t } this.destination = new ED(o) } } function oi(e) { Cn.useDeprecatedSynchronousErrorHandling ? function CD(e) { Cn.useDeprecatedSynchronousErrorHandling && _n && (_n.errorThrown = !0, _n.error = e) }(e) : Xc(e) } function ua(e, t) { const { onStoppedNotification: n } = Cn; n && ni.setTimeout(() => n(e, t)) } const SD = { closed: !0, next: Jc, error: function bD(e) { throw e }, complete: Jc }, la = "function" == typeof Symbol && Symbol.observable || "@@observable"; function En(e) { return e } function ed(e) { return 0 === e.length ? En : 1 === e.length ? e[0] : function (n) { return e.reduce((r, o) => o(r), n) } } let ye = (() => { class e { constructor(n) { n && (this._subscribe = n) } lift(n) { const r = new e; return r.source = this, r.operator = n, r } subscribe(n, r, o) { const i = function TD(e) { return e && e instanceof sa || function MD(e) { return e && X(e.next) && X(e.error) && X(e.complete) }(e) && Qc(e) }(n) ? n : new Hr(n, r, o); return ri(() => { const { operator: s, source: a } = this; i.add(s ? s.call(i, a) : a ? this._subscribe(i) : this._trySubscribe(i)) }), i } _trySubscribe(n) { try { return this._subscribe(n) } catch (r) { n.error(r) } } forEach(n, r) { return new (r = td(r))((o, i) => { const s = new Hr({ next: a => { try { n(a) } catch (u) { i(u), s.unsubscribe() } }, error: i, complete: o }); this.subscribe(s) }) } _subscribe(n) { var r; return null === (r = this.source) || void 0 === r ? void 0 : r.subscribe(n) } [la]() { return this } pipe(...n) { return ed(n)(this) } toPromise(n) { return new (n = td(n))((r, o) => { let i; this.subscribe(s => i = s, s => o(s), () => r(i)) }) } } return e.create = t => new e(t), e })(); function td(e) { var t; return null !== (t = e ?? Cn.Promise) && void 0 !== t ? t : Promise } const AD = Ur(e => function () { e(this), this.name = "ObjectUnsubscribedError", this.message = "object unsubscribed" }); let Vt = (() => { class e extends ye { constructor() { super(), this.closed = !1, this.currentObservers = null, this.observers = [], this.isStopped = !1, this.hasError = !1, this.thrownError = null } lift(n) { const r = new nd(this, this); return r.operator = n, r } _throwIfClosed() { if (this.closed) throw new AD } next(n) { ri(() => { if (this._throwIfClosed(), !this.isStopped) { this.currentObservers || (this.currentObservers = Array.from(this.observers)); for (const r of this.currentObservers) r.next(n) } }) } error(n) { ri(() => { if (this._throwIfClosed(), !this.isStopped) { this.hasError = this.isStopped = !0, this.thrownError = n; const { observers: r } = this; for (; r.length;)r.shift().error(n) } }) } complete() { ri(() => { if (this._throwIfClosed(), !this.isStopped) { this.isStopped = !0; const { observers: n } = this; for (; n.length;)n.shift().complete() } }) } unsubscribe() { this.isStopped = this.closed = !0, this.observers = this.currentObservers = null } get observed() { var n; return (null === (n = this.observers) || void 0 === n ? void 0 : n.length) > 0 } _trySubscribe(n) { return this._throwIfClosed(), super._trySubscribe(n) } _subscribe(n) { return this._throwIfClosed(), this._checkFinalizedStatuses(n), this._innerSubscribe(n) } _innerSubscribe(n) { const { hasError: r, isStopped: o, observers: i } = this; return r || o ? Yc : (this.currentObservers = null, i.push(n), new it(() => { this.currentObservers = null, Br(i, n) })) } _checkFinalizedStatuses(n) { const { hasError: r, thrownError: o, isStopped: i } = this; r ? n.error(o) : i && n.complete() } asObservable() { const n = new ye; return n.source = this, n } } return e.create = (t, n) => new nd(t, n), e })(); class nd extends Vt { constructor(t, n) { super(), this.destination = t, this.source = n } next(t) { var n, r; null === (r = null === (n = this.destination) || void 0 === n ? void 0 : n.next) || void 0 === r || r.call(n, t) } error(t) { var n, r; null === (r = null === (n = this.destination) || void 0 === n ? void 0 : n.error) || void 0 === r || r.call(n, t) } complete() { var t, n; null === (n = null === (t = this.destination) || void 0 === t ? void 0 : t.complete) || void 0 === n || n.call(t) } _subscribe(t) { var n, r; return null !== (r = null === (n = this.source) || void 0 === n ? void 0 : n.subscribe(t)) && void 0 !== r ? r : Yc } } function rd(e) { return X(e?.lift) } function _e(e) { return t => { if (rd(t)) return t.lift(function (n) { try { return e(n, this) } catch (r) { this.error(r) } }); throw new TypeError("Unable to lift unknown Observable type") } } function Ee(e, t, n, r, o) { return new RD(e, t, n, r, o) } class RD extends sa { constructor(t, n, r, o, i, s) { super(t), this.onFinalize = i, this.shouldUnsubscribe = s, this._next = n ? function (a) { try { n(a) } catch (u) { t.error(u) } } : super._next, this._error = o ? function (a) { try { o(a) } catch (u) { t.error(u) } finally { this.unsubscribe() } } : super._error, this._complete = r ? function () { try { r() } catch (a) { t.error(a) } finally { this.unsubscribe() } } : super._complete } unsubscribe() { var t; if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) { const { closed: n } = this; super.unsubscribe(), !n && (null === (t = this.onFinalize) || void 0 === t || t.call(this)) } } } function H(e, t) { return _e((n, r) => { let o = 0; n.subscribe(Ee(r, i => { r.next(e.call(t, i, o++)) })) }) } function sn(e) { return this instanceof sn ? (this.v = e, this) : new sn(e) } function ad(e) { if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined."); var n, t = e[Symbol.asyncIterator]; return t ? t.call(e) : (e = function ha(e) { var t = "function" == typeof Symbol && Symbol.iterator, n = t && e[t], r = 0; if (n) return n.call(e); if (e && "number" == typeof e.length) return { next: function () { return e && r >= e.length && (e = void 0), { value: e && e[r++], done: !e } } }; throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.") }(e), n = {}, r("next"), r("throw"), r("return"), n[Symbol.asyncIterator] = function () { return this }, n); function r(i) { n[i] = e[i] && function (s) { return new Promise(function (a, u) { !function o(i, s, a, u) { Promise.resolve(u).then(function (l) { i({ value: l, done: a }) }, s) }(a, u, (s = e[i](s)).done, s.value) }) } } } "function" == typeof SuppressedError && SuppressedError; const ud = e => e && "number" == typeof e.length && "function" != typeof e; function ld(e) { return X(e?.then) } function cd(e) { return X(e[la]) } function dd(e) { return Symbol.asyncIterator && X(e?.[Symbol.asyncIterator]) } function fd(e) { return new TypeError(`You provided ${null !== e && "object" == typeof e ? "an invalid object" : `'${e}'`} where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.`) } const hd = function XD() { return "function" == typeof Symbol && Symbol.iterator ? Symbol.iterator : "@@iterator" }(); function pd(e) { return X(e?.[hd]) } function gd(e) { return function sd(e, t, n) { if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined."); var o, r = n.apply(e, t || []), i = []; return o = {}, s("next"), s("throw"), s("return"), o[Symbol.asyncIterator] = function () { return this }, o; function s(f) { r[f] && (o[f] = function (h) { return new Promise(function (p, g) { i.push([f, h, p, g]) > 1 || a(f, h) }) }) } function a(f, h) { try { !function u(f) { f.value instanceof sn ? Promise.resolve(f.value.v).then(l, c) : d(i[0][2], f) }(r[f](h)) } catch (p) { d(i[0][3], p) } } function l(f) { a("next", f) } function c(f) { a("throw", f) } function d(f, h) { f(h), i.shift(), i.length && a(i[0][0], i[0][1]) } }(this, arguments, function* () { const n = e.getReader(); try { for (; ;) { const { value: r, done: o } = yield sn(n.read()); if (o) return yield sn(void 0); yield yield sn(r) } } finally { n.releaseLock() } }) } function md(e) { return X(e?.getReader) } function pt(e) { if (e instanceof ye) return e; if (null != e) { if (cd(e)) return function JD(e) { return new ye(t => { const n = e[la](); if (X(n.subscribe)) return n.subscribe(t); throw new TypeError("Provided object does not correctly implement Symbol.observable") }) }(e); if (ud(e)) return function ew(e) { return new ye(t => { for (let n = 0; n < e.length && !t.closed; n++)t.next(e[n]); t.complete() }) }(e); if (ld(e)) return function tw(e) { return new ye(t => { e.then(n => { t.closed || (t.next(n), t.complete()) }, n => t.error(n)).then(null, Xc) }) }(e); if (dd(e)) return yd(e); if (pd(e)) return function nw(e) { return new ye(t => { for (const n of e) if (t.next(n), t.closed) return; t.complete() }) }(e); if (md(e)) return function rw(e) { return yd(gd(e)) }(e) } throw fd(e) } function yd(e) { return new ye(t => { (function ow(e, t) { var n, r, o, i; return function od(e, t, n, r) { return new (n || (n = Promise))(function (i, s) { function a(c) { try { l(r.next(c)) } catch (d) { s(d) } } function u(c) { try { l(r.throw(c)) } catch (d) { s(d) } } function l(c) { c.done ? i(c.value) : function o(i) { return i instanceof n ? i : new n(function (s) { s(i) }) }(c.value).then(a, u) } l((r = r.apply(e, t || [])).next()) }) }(this, void 0, void 0, function* () { try { for (n = ad(e); !(r = yield n.next()).done;)if (t.next(r.value), t.closed) return } catch (s) { o = { error: s } } finally { try { r && !r.done && (i = n.return) && (yield i.call(n)) } finally { if (o) throw o.error } } t.complete() }) })(e, t).catch(n => t.error(n)) }) } function Ut(e, t, n, r = 0, o = !1) { const i = t.schedule(function () { n(), o ? e.add(this.schedule(null, r)) : this.unsubscribe() }, r); if (e.add(i), !o) return i } function be(e, t, n = 1 / 0) { return X(t) ? be((r, o) => H((i, s) => t(r, i, o, s))(pt(e(r, o))), n) : ("number" == typeof t && (n = t), _e((r, o) => function iw(e, t, n, r, o, i, s, a) { const u = []; let l = 0, c = 0, d = !1; const f = () => { d && !u.length && !l && t.complete() }, h = g => l < r ? p(g) : u.push(g), p = g => { i && t.next(g), l++; let y = !1; pt(n(g, c++)).subscribe(Ee(t, D => { o?.(D), i ? h(D) : t.next(D) }, () => { y = !0 }, void 0, () => { if (y) try { for (l--; u.length && l < r;) { const D = u.shift(); s ? Ut(t, s, () => p(D)) : p(D) } f() } catch (D) { t.error(D) } })) }; return e.subscribe(Ee(t, h, () => { d = !0, f() })), () => { a?.() } }(r, o, e, n))) } function Gn(e = 1 / 0) { return be(En, e) } const It = new ye(e => e.complete()); function pa(e) { return e[e.length - 1] } function zr(e) { return function aw(e) { return e && X(e.schedule) }(pa(e)) ? e.pop() : void 0 } function vd(e, t = 0) { return _e((n, r) => { n.subscribe(Ee(r, o => Ut(r, e, () => r.next(o), t), () => Ut(r, e, () => r.complete(), t), o => Ut(r, e, () => r.error(o), t))) }) } function Dd(e, t = 0) { return _e((n, r) => { r.add(e.schedule(() => n.subscribe(r), t)) }) } function wd(e, t) { if (!e) throw new Error("Iterable cannot be null"); return new ye(n => { Ut(n, t, () => { const r = e[Symbol.asyncIterator](); Ut(n, t, () => { r.next().then(o => { o.done ? n.complete() : n.next(o.value) }) }, 0, !0) }) }) } function ve(e, t) { return t ? function gw(e, t) { if (null != e) { if (cd(e)) return function cw(e, t) { return pt(e).pipe(Dd(t), vd(t)) }(e, t); if (ud(e)) return function fw(e, t) { return new ye(n => { let r = 0; return t.schedule(function () { r === e.length ? n.complete() : (n.next(e[r++]), n.closed || this.schedule()) }) }) }(e, t); if (ld(e)) return function dw(e, t) { return pt(e).pipe(Dd(t), vd(t)) }(e, t); if (dd(e)) return wd(e, t); if (pd(e)) return function hw(e, t) { return new ye(n => { let r; return Ut(n, t, () => { r = e[hd](), Ut(n, t, () => { let o, i; try { ({ value: o, done: i } = r.next()) } catch (s) { return void n.error(s) } i ? n.complete() : n.next(o) }, 0, !0) }), () => X(r?.return) && r.return() }) }(e, t); if (md(e)) return function pw(e, t) { return wd(gd(e), t) }(e, t) } throw fd(e) }(e, t) : pt(e) } function ga(e, t, ...n) { if (!0 === t) return void e(); if (!1 === t) return; const r = new Hr({ next: () => { r.unsubscribe(), e() } }); return pt(t(...n)).subscribe(r) } function K(e) { for (let t in e) if (e[t] === K) return t; throw Error("Could not find renamed property on target object.") } function J(e) { if ("string" == typeof e) return e; if (Array.isArray(e)) return "[" + e.map(J).join(", ") + "]"; if (null == e) return "" + e; if (e.overriddenName) return `${e.overriddenName}`; if (e.name) return `${e.name}`; const t = e.toString(); if (null == t) return "" + t; const n = t.indexOf("\n"); return -1 === n ? t : t.substring(0, n) } function ya(e, t) { return null == e || "" === e ? null === t ? "" : t : null == t || "" === t ? e : e + " " + t } const vw = K({ __forward_ref__: K }); function va(e) { return e.__forward_ref__ = va, e.toString = function () { return J(this()) }, e } function T(e) { return Da(e) ? e() : e } function Da(e) { return "function" == typeof e && e.hasOwnProperty(vw) && e.__forward_ref__ === va } function wa(e) { return e && !!e.\u0275providers } const Cd = "https://g.co/ng/security#xss"; class w extends Error { constructor(t, n) { super(ii(t, n)), this.code = t } } function ii(e, t) { return `NG0${Math.abs(e)}${t ? ": " + t.trim() : ""}` } function O(e) { return "string" == typeof e ? e : null == e ? "" : String(e) } function si(e, t) { throw new w(-201, !1) } function st(e, t) { null == e && function Y(e, t, n, r) { throw new Error(`ASSERTION ERROR: ${e}` + (null == r ? "" : ` [Expected=> ${n} ${r} ${t} <=Actual]`)) }(t, e, null, "!=") } function N(e) { return { token: e.token, providedIn: e.providedIn || null, factory: e.factory, value: void 0 } } function un(e) { return { providers: e.providers || [], imports: e.imports || [] } } function ai(e) { return _d(e, ui) || _d(e, bd) } function _d(e, t) { return e.hasOwnProperty(t) ? e[t] : null } function Ed(e) { return e && (e.hasOwnProperty(Ca) || e.hasOwnProperty(Iw)) ? e[Ca] : null } const ui = K({ \u0275prov: K }), Ca = K({ \u0275inj: K }), bd = K({ ngInjectableDef: K }), Iw = K({ ngInjectorDef: K }); var A = (() => ((A = A || {})[A.Default = 0] = "Default", A[A.Host = 1] = "Host", A[A.Self = 2] = "Self", A[A.SkipSelf = 4] = "SkipSelf", A[A.Optional = 8] = "Optional", A))(); let _a; function at(e) { const t = _a; return _a = e, t } function Sd(e, t, n) { const r = ai(e); return r && "root" == r.providedIn ? void 0 === r.value ? r.value = r.factory() : r.value : n & A.Optional ? null : void 0 !== t ? t : void si(J(e)) } const te = (() => typeof globalThis < "u" && globalThis || typeof global < "u" && global || typeof window < "u" && window || typeof self < "u" && typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope && self)(), Gr = {}, Ea = "__NG_DI_FLAG__", li = "ngTempTokenPath", Tw = "ngTokenPath", Aw = /\n/gm, Rw = "\u0275", Id = "__source"; let Wr; function Wn(e) { const t = Wr; return Wr = e, t } function xw(e, t = A.Default) { if (void 0 === Wr) throw new w(-203, !1); return null === Wr ? Sd(e, void 0, t) : Wr.get(e, t & A.Optional ? null : void 0, t) } function R(e, t = A.Default) { return (function Mw() { return _a }() || xw)(T(e), t) } function z(e, t = A.Default) { return R(e, ci(t)) } function ci(e) { return typeof e > "u" || "number" == typeof e ? e : 0 | (e.optional && 8) | (e.host && 1) | (e.self && 2) | (e.skipSelf && 4) } function ba(e) { const t = []; for (let n = 0; n < e.length; n++) { const r = T(e[n]); if (Array.isArray(r)) { if (0 === r.length) throw new w(900, !1); let o, i = A.Default; for (let s = 0; s < r.length; s++) { const a = r[s], u = Pw(a); "number" == typeof u ? -1 === u ? o = a.token : i |= u : o = a } t.push(R(o, i)) } else t.push(R(r)) } return t } function qr(e, t) { return e[Ea] = t, e.prototype[Ea] = t, e } function Pw(e) { return e[Ea] } function Bt(e) { return { toString: e }.toString() } var Mt = (() => ((Mt = Mt || {})[Mt.OnPush = 0] = "OnPush", Mt[Mt.Default = 1] = "Default", Mt))(), Tt = (() => { return (e = Tt || (Tt = {}))[e.Emulated = 0] = "Emulated", e[e.None = 2] = "None", e[e.ShadowDom = 3] = "ShadowDom", Tt; var e })(); const Ht = {}, W = [], di = K({ \u0275cmp: K }), Sa = K({ \u0275dir: K }), Ia = K({ \u0275pipe: K }), Td = K({ \u0275mod: K }), zt = K({ \u0275fac: K }), Zr = K({ __NG_ELEMENT_ID__: K }); let Fw = 0; function Yr(e) { return Bt(() => { const t = Rd(e), n = { ...t, decls: e.decls, vars: e.vars, template: e.template, consts: e.consts || null, ngContentSelectors: e.ngContentSelectors, onPush: e.changeDetection === Mt.OnPush, directiveDefs: null, pipeDefs: null, dependencies: t.standalone && e.dependencies || null, getStandaloneInjector: null, data: e.data || {}, encapsulation: e.encapsulation || Tt.Emulated, id: "c" + Fw++, styles: e.styles || W, _: null, schemas: e.schemas || null, tView: null }; xd(n); const r = e.dependencies; return n.directiveDefs = fi(r, !1), n.pipeDefs = fi(r, !0), n }) } function Lw(e) { return Q(e) || Te(e) } function jw(e) { return null !== e } function bn(e) { return Bt(() => ({ type: e.type, bootstrap: e.bootstrap || W, declarations: e.declarations || W, imports: e.imports || W, exports: e.exports || W, transitiveCompileScopes: null, schemas: e.schemas || null, id: e.id || null })) } function Ad(e, t) { if (null == e) return Ht; const n = {}; for (const r in e) if (e.hasOwnProperty(r)) { let o = e[r], i = o; Array.isArray(o) && (i = o[1], o = o[0]), n[o] = r, t && (t[o] = i) } return n } function ke(e) { return Bt(() => { const t = Rd(e); return xd(t), t }) } function Q(e) { return e[di] || null } function Te(e) { return e[Sa] || null } function ze(e) { return e[Ia] || null } function Xe(e, t) { const n = e[Td] || null; if (!n && !0 === t) throw new Error(`Type ${J(e)} does not have '\u0275mod' property.`); return n } function Rd(e) { const t = {}; return { type: e.type, providersResolver: null, factory: null, hostBindings: e.hostBindings || null, hostVars: e.hostVars || 0, hostAttrs: e.hostAttrs || null, contentQueries: e.contentQueries || null, declaredInputs: t, exportAs: e.exportAs || null, standalone: !0 === e.standalone, selectors: e.selectors || W, viewQuery: e.viewQuery || null, features: e.features || null, setInput: null, findHostDirectiveDefs: null, hostDirectives: null, inputs: Ad(e.inputs, t), outputs: Ad(e.outputs) } } function xd(e) { e.features?.forEach(t => t(e)) } function fi(e, t) { if (!e) return null; const n = t ? ze : Lw; return () => ("function" == typeof e ? e() : e).map(r => n(r)).filter(jw) } const Gt = 0, E = 1, j = 2, ae = 3, gt = 4, Sn = 5, Ae = 6, Zn = 7, le = 8, hi = 9, pi = 10, V = 11, Ma = 12, Qr = 13, Pd = 14, Yn = 15, Re = 16, Kr = 17, Qn = 18, At = 19, Xr = 20, Nd = 21, ne = 22, Ta = 1, Od = 2, gi = 7, mi = 8, Kn = 9, Le = 10; function Je(e) { return Array.isArray(e) && "object" == typeof e[Ta] } function mt(e) { return Array.isArray(e) && !0 === e[Ta] } function Aa(e) { return 0 != (4 & e.flags) } function Jr(e) { return e.componentOffset > -1 } function yi(e) { return 1 == (1 & e.flags) } function yt(e) { return !!e.template } function Vw(e) { return 0 != (256 & e[j]) } function In(e, t) { return e.hasOwnProperty(zt) ? e[zt] : null } class Hw { constructor(t, n, r) { this.previousValue = t, this.currentValue = n, this.firstChange = r } isFirstChange() { return this.firstChange } } function Mn() { return Ld } function Ld(e) { return e.type.prototype.ngOnChanges && (e.setInput = Gw), zw } function zw() { const e = $d(this), t = e?.current; if (t) { const n = e.previous; if (n === Ht) e.previous = t; else for (let r in t) n[r] = t[r]; e.current = null, this.ngOnChanges(t) } } function Gw(e, t, n, r) { const o = this.declaredInputs[n], i = $d(e) || function Ww(e, t) { return e[jd] = t }(e, { previous: Ht, current: null }), s = i.current || (i.current = {}), a = i.previous, u = a[o]; s[o] = new Hw(u && u.currentValue, t, a === Ht), e[r] = t } Mn.ngInherit = !0; const jd = "__ngSimpleChanges__"; function $d(e) { return e[jd] || null } const ut = function (e, t, n) { }; function Se(e) { for (; Array.isArray(e);)e = e[Gt]; return e } function vi(e, t) { return Se(t[e]) } function et(e, t) { return Se(t[e.index]) } function Bd(e, t) { return e.data[t] } function Ge(e, t) { const n = t[e]; return Je(n) ? n : n[Gt] } function Di(e) { return 64 == (64 & e[j]) } function ln(e, t) { return null == t ? null : e[t] } function Hd(e) { e[Qn] = 0 } function xa(e, t) { e[Sn] += t; let n = e, r = e[ae]; for (; null !== r && (1 === t && 1 === n[Sn] || -1 === t && 0 === n[Sn]);)r[Sn] += t, n = r, r = r[ae] } const F = { lFrame: Jd(null), bindingsEnabled: !0 }; function Gd() { return F.bindingsEnabled } function v() { return F.lFrame.lView } function G() { return F.lFrame.tView } function Ie() { let e = Wd(); for (; null !== e && 64 === e.type;)e = e.parent; return e } function Wd() { return F.lFrame.currentTNode } function Rt(e, t) { const n = F.lFrame; n.currentTNode = e, n.isParent = t } function Pa() { return F.lFrame.isParent } function je() { const e = F.lFrame; let t = e.bindingRootIndex; return -1 === t && (t = e.bindingRootIndex = e.tView.bindingStartIndex), t } function Jn() { return F.lFrame.bindingIndex++ } function aC(e, t) { const n = F.lFrame; n.bindingIndex = n.bindingRootIndex = e, Oa(t) } function Oa(e) { F.lFrame.currentDirectiveIndex = e } function ka(e) { F.lFrame.currentQueryIndex = e } function lC(e) { const t = e[E]; return 2 === t.type ? t.declTNode : 1 === t.type ? e[Ae] : null } function Kd(e, t, n) { if (n & A.SkipSelf) { let o = t, i = e; for (; !(o = o.parent, null !== o || n & A.Host || (o = lC(i), null === o || (i = i[Yn], 10 & o.type)));); if (null === o) return !1; t = o, e = i } const r = F.lFrame = Xd(); return r.currentTNode = t, r.lView = e, !0 } function La(e) { const t = Xd(), n = e[E]; F.lFrame = t, t.currentTNode = n.firstChild, t.lView = e, t.tView = n, t.contextLView = e, t.bindingIndex = n.bindingStartIndex, t.inI18n = !1 } function Xd() { const e = F.lFrame, t = null === e ? null : e.child; return null === t ? Jd(e) : t } function Jd(e) { const t = { currentTNode: null, isParent: !0, lView: null, tView: null, selectedIndex: -1, contextLView: null, elementDepthCount: 0, currentNamespace: null, currentDirectiveIndex: -1, bindingRootIndex: -1, bindingIndex: -1, currentQueryIndex: 0, parent: e, child: null, inI18n: !1 }; return null !== e && (e.child = t), t } function ef() { const e = F.lFrame; return F.lFrame = e.parent, e.currentTNode = null, e.lView = null, e } const tf = ef; function ja() { const e = ef(); e.isParent = !0, e.tView = null, e.selectedIndex = -1, e.contextLView = null, e.elementDepthCount = 0, e.currentDirectiveIndex = -1, e.currentNamespace = null, e.bindingRootIndex = -1, e.bindingIndex = -1, e.currentQueryIndex = 0 } function $e() { return F.lFrame.selectedIndex } function Tn(e) { F.lFrame.selectedIndex = e } function oe() { const e = F.lFrame; return Bd(e.tView, e.selectedIndex) } function wi(e, t) { for (let n = t.directiveStart, r = t.directiveEnd; n < r; n++) { const i = e.data[n].type.prototype, { ngAfterContentInit: s, ngAfterContentChecked: a, ngAfterViewInit: u, ngAfterViewChecked: l, ngOnDestroy: c } = i; s && (e.contentHooks ?? (e.contentHooks = [])).push(-n, s), a && ((e.contentHooks ?? (e.contentHooks = [])).push(n, a), (e.contentCheckHooks ?? (e.contentCheckHooks = [])).push(n, a)), u && (e.viewHooks ?? (e.viewHooks = [])).push(-n, u), l && ((e.viewHooks ?? (e.viewHooks = [])).push(n, l), (e.viewCheckHooks ?? (e.viewCheckHooks = [])).push(n, l)), null != c && (e.destroyHooks ?? (e.destroyHooks = [])).push(n, c) } } function Ci(e, t, n) { nf(e, t, 3, n) } function _i(e, t, n, r) { (3 & e[j]) === n && nf(e, t, n, r) } function $a(e, t) { let n = e[j]; (3 & n) === t && (n &= 2047, n += 1, e[j] = n) } function nf(e, t, n, r) { const i = r ?? -1, s = t.length - 1; let a = 0; for (let u = void 0 !== r ? 65535 & e[Qn] : 0; u < s; u++)if ("number" == typeof t[u + 1]) { if (a = t[u], null != r && a >= r) break } else t[u] < 0 && (e[Qn] += 65536), (a < i || -1 == i) && (vC(e, n, t, u), e[Qn] = (4294901760 & e[Qn]) + u + 2), u++ } function vC(e, t, n, r) { const o = n[r] < 0, i = n[r + 1], a = e[o ? -n[r] : n[r]]; if (o) { if (e[j] >> 11 < e[Qn] >> 16 && (3 & e[j]) === t) { e[j] += 2048, ut(4, a, i); try { i.call(a) } finally { ut(5, a, i) } } } else { ut(4, a, i); try { i.call(a) } finally { ut(5, a, i) } } } const er = -1; class to { constructor(t, n, r) { this.factory = t, this.resolving = !1, this.canSeeViewProviders = n, this.injectImpl = r } } function Ua(e, t, n) { let r = 0; for (; r < n.length;) { const o = n[r]; if ("number" == typeof o) { if (0 !== o) break; r++; const i = n[r++], s = n[r++], a = n[r++]; e.setAttribute(t, s, a, i) } else { const i = o, s = n[++r]; sf(i) ? e.setProperty(t, i, s) : e.setAttribute(t, i, s), r++ } } return r } function rf(e) { return 3 === e || 4 === e || 6 === e } function sf(e) { return 64 === e.charCodeAt(0) } function no(e, t) { if (null !== t && 0 !== t.length) if (null === e || 0 === e.length) e = t.slice(); else { let n = -1; for (let r = 0; r < t.length; r++) { const o = t[r]; "number" == typeof o ? n = o : 0 === n || af(e, n, o, null, -1 === n || 2 === n ? t[++r] : null) } } return e } function af(e, t, n, r, o) { let i = 0, s = e.length; if (-1 === t) s = -1; else for (; i < e.length;) { const a = e[i++]; if ("number" == typeof a) { if (a === t) { s = -1; break } if (a > t) { s = i - 1; break } } } for (; i < e.length;) { const a = e[i]; if ("number" == typeof a) break; if (a === n) { if (null === r) return void (null !== o && (e[i + 1] = o)); if (r === e[i + 1]) return void (e[i + 2] = o) } i++, null !== r && i++, null !== o && i++ } -1 !== s && (e.splice(s, 0, t), i = s + 1), e.splice(i++, 0, n), null !== r && e.splice(i++, 0, r), null !== o && e.splice(i++, 0, o) } function uf(e) { return e !== er } function Ei(e) { return 32767 & e } function bi(e, t) { let n = function _C(e) { return e >> 16 }(e), r = t; for (; n > 0;)r = r[Yn], n--; return r } let Ba = !0; function Si(e) { const t = Ba; return Ba = e, t } const lf = 255, cf = 5; let EC = 0; const xt = {}; function Ii(e, t) { const n = df(e, t); if (-1 !== n) return n; const r = t[E]; r.firstCreatePass && (e.injectorIndex = t.length, Ha(r.data, e), Ha(t, null), Ha(r.blueprint, null)); const o = za(e, t), i = e.injectorIndex; if (uf(o)) { const s = Ei(o), a = bi(o, t), u = a[E].data; for (let l = 0; l < 8; l++)t[i + l] = a[s + l] | u[s + l] } return t[i + 8] = o, i } function Ha(e, t) { e.push(0, 0, 0, 0, 0, 0, 0, 0, t) } function df(e, t) { return -1 === e.injectorIndex || e.parent && e.parent.injectorIndex === e.injectorIndex || null === t[e.injectorIndex + 8] ? -1 : e.injectorIndex } function za(e, t) { if (e.parent && -1 !== e.parent.injectorIndex) return e.parent.injectorIndex; let n = 0, r = null, o = t; for (; null !== o;) { if (r = Df(o), null === r) return er; if (n++, o = o[Yn], -1 !== r.injectorIndex) return r.injectorIndex | n << 16 } return er } function Ga(e, t, n) { !function bC(e, t, n) { let r; "string" == typeof n ? r = n.charCodeAt(0) || 0 : n.hasOwnProperty(Zr) && (r = n[Zr]), null == r && (r = n[Zr] = EC++); const o = r & lf; t.data[e + (o >> cf)] |= 1 << o }(e, t, n) } function ff(e, t, n) { if (n & A.Optional || void 0 !== e) return e; si() } function hf(e, t, n, r) { if (n & A.Optional && void 0 === r && (r = null), !(n & (A.Self | A.Host))) { const o = e[hi], i = at(void 0); try { return o ? o.get(t, r, n & A.Optional) : Sd(t, r, n & A.Optional) } finally { at(i) } } return ff(r, 0, n) } function pf(e, t, n, r = A.Default, o) { if (null !== e) { if (1024 & t[j]) { const s = function AC(e, t, n, r, o) { let i = e, s = t; for (; null !== i && null !== s && 1024 & s[j] && !(256 & s[j]);) { const a = gf(i, s, n, r | A.Self, xt); if (a !== xt) return a; let u = i.parent; if (!u) { const l = s[Nd]; if (l) { const c = l.get(n, xt, r); if (c !== xt) return c } u = Df(s), s = s[Yn] } i = u } return o }(e, t, n, r, xt); if (s !== xt) return s } const i = gf(e, t, n, r, xt); if (i !== xt) return i } return hf(t, n, r, o) } function gf(e, t, n, r, o) { const i = function MC(e) { if ("string" == typeof e) return e.charCodeAt(0) || 0; const t = e.hasOwnProperty(Zr) ? e[Zr] : void 0; return "number" == typeof t ? t >= 0 ? t & lf : TC : t }(n); if ("function" == typeof i) { if (!Kd(t, e, r)) return r & A.Host ? ff(o, 0, r) : hf(t, n, r, o); try { const s = i(r); if (null != s || r & A.Optional) return s; si() } finally { tf() } } else if ("number" == typeof i) { let s = null, a = df(e, t), u = er, l = r & A.Host ? t[Re][Ae] : null; for ((-1 === a || r & A.SkipSelf) && (u = -1 === a ? za(e, t) : t[a + 8], u !== er && yf(r, !1) ? (s = t[E], a = Ei(u), t = bi(u, t)) : a = -1); -1 !== a;) { const c = t[E]; if (mf(i, a, c.data)) { const d = IC(a, t, n, s, r, l); if (d !== xt) return d } u = t[a + 8], u !== er && yf(r, t[E].data[a + 8] === l) && mf(i, a, t) ? (s = c, a = Ei(u), t = bi(u, t)) : a = -1 } } return o } function IC(e, t, n, r, o, i) { const s = t[E], a = s.data[e + 8], c = function Mi(e, t, n, r, o) { const i = e.providerIndexes, s = t.data, a = 1048575 & i, u = e.directiveStart, c = i >> 20, f = o ? a + c : e.directiveEnd; for (let h = r ? a : a + c; h < f; h++) { const p = s[h]; if (h < u && n === p || h >= u && p.type === n) return h } if (o) { const h = s[u]; if (h && yt(h) && h.type === n) return u } return null }(a, s, n, null == r ? Jr(a) && Ba : r != s && 0 != (3 & a.type), o & A.Host && i === a); return null !== c ? An(t, s, c, a) : xt } function An(e, t, n, r) { let o = e[n]; const i = t.data; if (function DC(e) { return e instanceof to }(o)) { const s = o; s.resolving && function Dw(e, t) { const n = t ? `. Dependency path: ${t.join(" > ")} > ${e}` : ""; throw new w(-200, `Circular dependency in DI detected for ${e}${n}`) }(function Z(e) { return "function" == typeof e ? e.name || e.toString() : "object" == typeof e && null != e && "function" == typeof e.type ? e.type.name || e.type.toString() : O(e) }(i[n])); const a = Si(s.canSeeViewProviders); s.resolving = !0; const u = s.injectImpl ? at(s.injectImpl) : null; Kd(e, r, A.Default); try { o = e[n] = s.factory(void 0, i, e, r), t.firstCreatePass && n >= r.directiveStart && function yC(e, t, n) { const { ngOnChanges: r, ngOnInit: o, ngDoCheck: i } = t.type.prototype; if (r) { const s = Ld(t); (n.preOrderHooks ?? (n.preOrderHooks = [])).push(e, s), (n.preOrderCheckHooks ?? (n.preOrderCheckHooks = [])).push(e, s) } o && (n.preOrderHooks ?? (n.preOrderHooks = [])).push(0 - e, o), i && ((n.preOrderHooks ?? (n.preOrderHooks = [])).push(e, i), (n.preOrderCheckHooks ?? (n.preOrderCheckHooks = [])).push(e, i)) }(n, i[n], t) } finally { null !== u && at(u), Si(a), s.resolving = !1, tf() } } return o } function mf(e, t, n) { return !!(n[t + (e >> cf)] & 1 << e) } function yf(e, t) { return !(e & A.Self || e & A.Host && t) } class tr { constructor(t, n) { this._tNode = t, this._lView = n } get(t, n, r) { return pf(this._tNode, this._lView, t, ci(r), n) } } function TC() { return new tr(Ie(), v()) } function Wa(e) { return Da(e) ? () => { const t = Wa(T(e)); return t && t() } : In(e) } function Df(e) { const t = e[E], n = t.type; return 2 === n ? t.declTNode : 1 === n ? e[Ae] : null } const rr = "__parameters__"; function ir(e, t, n) { return Bt(() => { const r = function qa(e) { return function (...n) { if (e) { const r = e(...n); for (const o in r) this[o] = r[o] } } }(t); function o(...i) { if (this instanceof o) return r.apply(this, i), this; const s = new o(...i); return a.annotation = s, a; function a(u, l, c) { const d = u.hasOwnProperty(rr) ? u[rr] : Object.defineProperty(u, rr, { value: [] })[rr]; for (; d.length <= c;)d.push(null); return (d[c] = d[c] || []).push(s), u } } return n && (o.prototype = Object.create(n.prototype)), o.prototype.ngMetadataName = e, o.annotationCls = o, o }) } class x { constructor(t, n) { this._desc = t, this.ngMetadataName = "InjectionToken", this.\u0275prov = void 0, "number" == typeof n ? this.__NG_ELEMENT_ID__ = n : void 0 !== n && (this.\u0275prov = N({ token: this, providedIn: n.providedIn || "root", factory: n.factory })) } get multi() { return this } toString() { return `InjectionToken ${this._desc}` } } function Rn(e, t) { e.forEach(n => Array.isArray(n) ? Rn(n, t) : t(n)) } function Cf(e, t, n) { t >= e.length ? e.push(n) : e.splice(t, 0, n) } function Ai(e, t) { return t >= e.length - 1 ? e.pop() : e.splice(t, 1)[0] } function tt(e, t, n) { let r = sr(e, t); return r >= 0 ? e[1 | r] = n : (r = ~r, function NC(e, t, n, r) { let o = e.length; if (o == t) e.push(n, r); else if (1 === o) e.push(r, e[0]), e[0] = n; else { for (o--, e.push(e[o - 1], e[o]); o > t;)e[o] = e[o - 2], o--; e[t] = n, e[t + 1] = r } }(e, r, t, n)), r } function Ya(e, t) { const n = sr(e, t); if (n >= 0) return e[1 | n] } function sr(e, t) { return function _f(e, t, n) { let r = 0, o = e.length >> n; for (; o !== r;) { const i = r + (o - r >> 1), s = e[i << n]; if (t === s) return i << n; s > t ? o = i : r = i + 1 } return ~(o << n) }(e, t, 1) } const so = qr(ir("Optional"), 8), ao = qr(ir("SkipSelf"), 4); var We = (() => ((We = We || {})[We.Important = 1] = "Important", We[We.DashCase = 2] = "DashCase", We))(); const tu = new Map; let t_ = 0; const ru = "__ngContext__"; function xe(e, t) { Je(t) ? (e[ru] = t[Xr], function r_(e) { tu.set(e[Xr], e) }(t)) : e[ru] = t } let ou; function iu(e, t) { return ou(e, t) } function fo(e) { const t = e[ae]; return mt(t) ? t[ae] : t } function su(e) { return Bf(e[Qr]) } function au(e) { return Bf(e[gt]) } function Bf(e) { for (; null !== e && !mt(e);)e = e[gt]; return e } function ur(e, t, n, r, o) { if (null != r) { let i, s = !1; mt(r) ? i = r : Je(r) && (s = !0, r = r[Gt]); const a = Se(r); 0 === e && null !== n ? null == o ? Zf(t, n, a) : xn(t, n, a, o || null, !0) : 1 === e && null !== n ? xn(t, n, a, o || null, !0) : 2 === e ? function pu(e, t, n) { const r = Ni(e, t); r && function E_(e, t, n, r) { e.removeChild(t, n, r) }(e, r, t, n) }(t, a, s) : 3 === e && t.destroyNode(a), null != i && function I_(e, t, n, r, o) { const i = n[gi]; i !== Se(n) && ur(t, e, r, i, o); for (let a = Le; a < n.length; a++) { const u = n[a]; ho(u[E], u, e, t, r, i) } }(t, e, i, n, o) } } function lu(e, t, n) { return e.createElement(t, n) } function zf(e, t) { const n = e[Kn], r = n.indexOf(t), o = t[ae]; 512 & t[j] && (t[j] &= -513, xa(o, -1)), n.splice(r, 1) } function cu(e, t) { if (e.length <= Le) return; const n = Le + t, r = e[n]; if (r) { const o = r[Kr]; null !== o && o !== e && zf(o, r), t > 0 && (e[n - 1][gt] = r[gt]); const i = Ai(e, Le + t); !function g_(e, t) { ho(e, t, t[V], 2, null, null), t[Gt] = null, t[Ae] = null }(r[E], r); const s = i[At]; null !== s && s.detachView(i[E]), r[ae] = null, r[gt] = null, r[j] &= -65 } return r } function Gf(e, t) { if (!(128 & t[j])) { const n = t[V]; n.destroyNode && ho(e, t, n, 3, null, null), function v_(e) { let t = e[Qr]; if (!t) return du(e[E], e); for (; t;) { let n = null; if (Je(t)) n = t[Qr]; else { const r = t[Le]; r && (n = r) } if (!n) { for (; t && !t[gt] && t !== e;)Je(t) && du(t[E], t), t = t[ae]; null === t && (t = e), Je(t) && du(t[E], t), n = t && t[gt] } t = n } }(t) } } function du(e, t) { if (!(128 & t[j])) { t[j] &= -65, t[j] |= 128, function __(e, t) { let n; if (null != e && null != (n = e.destroyHooks)) for (let r = 0; r < n.length; r += 2) { const o = t[n[r]]; if (!(o instanceof to)) { const i = n[r + 1]; if (Array.isArray(i)) for (let s = 0; s < i.length; s += 2) { const a = o[i[s]], u = i[s + 1]; ut(4, a, u); try { u.call(a) } finally { ut(5, a, u) } } else { ut(4, o, i); try { i.call(o) } finally { ut(5, o, i) } } } } }(e, t), function C_(e, t) { const n = e.cleanup, r = t[Zn]; let o = -1; if (null !== n) for (let i = 0; i < n.length - 1; i += 2)if ("string" == typeof n[i]) { const s = n[i + 3]; s >= 0 ? r[o = s]() : r[o = -s].unsubscribe(), i += 2 } else { const s = r[o = n[i + 1]]; n[i].call(s) } if (null !== r) { for (let i = o + 1; i < r.length; i++)(0, r[i])(); t[Zn] = null } }(e, t), 1 === t[E].type && t[V].destroy(); const n = t[Kr]; if (null !== n && mt(t[ae])) { n !== t[ae] && zf(n, t); const r = t[At]; null !== r && r.detachView(e) } !function o_(e) { tu.delete(e[Xr]) }(t) } } function Wf(e, t, n) { return function qf(e, t, n) { let r = t; for (; null !== r && 40 & r.type;)r = (t = r).parent; if (null === r) return n[Gt]; { const { componentOffset: o } = r; if (o > -1) { const { encapsulation: i } = e.data[r.directiveStart + o]; if (i === Tt.None || i === Tt.Emulated) return null } return et(r, n) } }(e, t.parent, n) } function xn(e, t, n, r, o) { e.insertBefore(t, n, r, o) } function Zf(e, t, n) { e.appendChild(t, n) } function Yf(e, t, n, r, o) { null !== r ? xn(e, t, n, r, o) : Zf(e, t, n) } function Ni(e, t) { return e.parentNode(t) } let fu, yu, Li, Xf = function Kf(e, t, n) { return 40 & e.type ? et(e, n) : null }; function Oi(e, t, n, r) { const o = Wf(e, r, t), i = t[V], a = function Qf(e, t, n) { return Xf(e, t, n) }(r.parent || t[Ae], r, t); if (null != o) if (Array.isArray(n)) for (let u = 0; u < n.length; u++)Yf(i, o, n[u], a, !1); else Yf(i, o, n, a, !1); void 0 !== fu && fu(i, r, t, n, o) } function Fi(e, t) { if (null !== t) { const n = t.type; if (3 & n) return et(t, e); if (4 & n) return hu(-1, e[t.index]); if (8 & n) { const r = t.child; if (null !== r) return Fi(e, r); { const o = e[t.index]; return mt(o) ? hu(-1, o) : Se(o) } } if (32 & n) return iu(t, e)() || Se(e[t.index]); { const r = eh(e, t); return null !== r ? Array.isArray(r) ? r[0] : Fi(fo(e[Re]), r) : Fi(e, t.next) } } return null } function eh(e, t) { return null !== t ? e[Re][Ae].projection[t.projection] : null } function hu(e, t) { const n = Le + e + 1; if (n < t.length) { const r = t[n], o = r[E].firstChild; if (null !== o) return Fi(r, o) } return t[gi] } function gu(e, t, n, r, o, i, s) { for (; null != n;) { const a = r[n.index], u = n.type; if (s && 0 === t && (a && xe(Se(a), r), n.flags |= 2), 32 != (32 & n.flags)) if (8 & u) gu(e, t, n.child, r, o, i, !1), ur(t, e, o, a, i); else if (32 & u) { const l = iu(n, r); let c; for (; c = l();)ur(t, e, o, c, i); ur(t, e, o, a, i) } else 16 & u ? th(e, t, r, n, o, i) : ur(t, e, o, a, i); n = s ? n.projectionNext : n.next } } function ho(e, t, n, r, o, i) { gu(n, r, e.firstChild, t, o, i, !1) } function th(e, t, n, r, o, i) { const s = n[Re], u = s[Ae].projection[r.projection]; if (Array.isArray(u)) for (let l = 0; l < u.length; l++)ur(t, e, o, u[l], i); else gu(e, t, u, s[ae], o, i, !0) } function nh(e, t, n) { "" === n ? e.removeAttribute(t, "class") : e.setAttribute(t, "class", n) } function rh(e, t, n) { const { mergedAttrs: r, classes: o, styles: i } = n; null !== r && Ua(e, t, r), null !== o && nh(e, t, o), null !== i && function T_(e, t, n) { e.setAttribute(t, "style", n) }(e, t, i) } function ah(e) { return function vu() { if (void 0 === Li && (Li = null, te.trustedTypes)) try { Li = te.trustedTypes.createPolicy("angular#unsafe-bypass", { createHTML: e => e, createScript: e => e, createScriptURL: e => e }) } catch { } return Li }()?.createScriptURL(e) || e } class uh { constructor(t) { this.changingThisBreaksApplicationSecurity = t } toString() { return `SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity} (see ${Cd})` } } function cn(e) { return e instanceof uh ? e.changingThisBreaksApplicationSecurity : e } function po(e, t) { const n = function j_(e) { return e instanceof uh && e.getTypeName() || null }(e); if (null != n && n !== t) { if ("ResourceURL" === n && "URL" === t) return !0; throw new Error(`Required a safe ${t}, got a ${n} (see ${Cd})`) } return n === t } const B_ = /^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:\/?#]*(?:[\/?#]|$))/i; var pe = (() => ((pe = pe || {})[pe.NONE = 0] = "NONE", pe[pe.HTML = 1] = "HTML", pe[pe.STYLE = 2] = "STYLE", pe[pe.SCRIPT = 3] = "SCRIPT", pe[pe.URL = 4] = "URL", pe[pe.RESOURCE_URL = 5] = "RESOURCE_URL", pe))(); function $i(e) { const t = mo(); return t ? t.sanitize(pe.URL, e) || "" : po(e, "URL") ? cn(e) : function Du(e) { return (e = String(e)).match(B_) ? e : "unsafe:" + e }(O(e)) } function gh(e) { const t = mo(); if (t) return ah(t.sanitize(pe.RESOURCE_URL, e) || ""); if (po(e, "ResourceURL")) return ah(cn(e)); throw new w(904, !1) } function mo() { const e = v(); return e && e[Ma] } const Vi = new x("ENVIRONMENT_INITIALIZER"), yh = new x("INJECTOR", -1), vh = new x("INJECTOR_DEF_TYPES"); class Dh { get(t, n = Gr) { if (n === Gr) { const r = new Error(`NullInjectorError: No provider for ${J(t)}!`); throw r.name = "NullInjectorError", r } return n } } function tE(...e) { return { \u0275providers: wh(0, e), \u0275fromNgModule: !0 } } function wh(e, ...t) { const n = [], r = new Set; let o; return Rn(t, i => { const s = i; Eu(s, n, [], r) && (o || (o = []), o.push(s)) }), void 0 !== o && Ch(o, n), n } function Ch(e, t) { for (let n = 0; n < e.length; n++) { const { providers: o } = e[n]; bu(o, i => { t.push(i) }) } } function Eu(e, t, n, r) { if (!(e = T(e))) return !1; let o = null, i = Ed(e); const s = !i && Q(e); if (i || s) { if (s && !s.standalone) return !1; o = e } else { const u = e.ngModule; if (i = Ed(u), !i) return !1; o = u } const a = r.has(o); if (s) { if (a) return !1; if (r.add(o), s.dependencies) { const u = "function" == typeof s.dependencies ? s.dependencies() : s.dependencies; for (const l of u) Eu(l, t, n, r) } } else { if (!i) return !1; { if (null != i.imports && !a) { let l; r.add(o); try { Rn(i.imports, c => { Eu(c, t, n, r) && (l || (l = []), l.push(c)) }) } finally { } void 0 !== l && Ch(l, t) } if (!a) { const l = In(o) || (() => new o); t.push({ provide: o, useFactory: l, deps: W }, { provide: vh, useValue: o, multi: !0 }, { provide: Vi, useValue: () => R(o), multi: !0 }) } const u = i.providers; null == u || a || bu(u, c => { t.push(c) }) } } return o !== e && void 0 !== e.providers } function bu(e, t) { for (let n of e) wa(n) && (n = n.\u0275providers), Array.isArray(n) ? bu(n, t) : t(n) } const nE = K({ provide: String, useValue: K }); function Su(e) { return null !== e && "object" == typeof e && nE in e } function Pn(e) { return "function" == typeof e } const Iu = new x("Set Injector scope."), Ui = {}, oE = {}; let Mu; function Bi() { return void 0 === Mu && (Mu = new Dh), Mu } class Yt { } class bh extends Yt { get destroyed() { return this._destroyed } constructor(t, n, r, o) { super(), this.parent = n, this.source = r, this.scopes = o, this.records = new Map, this._ngOnDestroyHooks = new Set, this._onDestroyHooks = [], this._destroyed = !1, Au(t, s => this.processProvider(s)), this.records.set(yh, cr(void 0, this)), o.has("environment") && this.records.set(Yt, cr(void 0, this)); const i = this.records.get(Iu); null != i && "string" == typeof i.value && this.scopes.add(i.value), this.injectorDefTypes = new Set(this.get(vh.multi, W, A.Self)) } destroy() { this.assertNotDestroyed(), this._destroyed = !0; try { for (const t of this._ngOnDestroyHooks) t.ngOnDestroy(); for (const t of this._onDestroyHooks) t() } finally { this.records.clear(), this._ngOnDestroyHooks.clear(), this.injectorDefTypes.clear(), this._onDestroyHooks.length = 0 } } onDestroy(t) { this._onDestroyHooks.push(t) } runInContext(t) { this.assertNotDestroyed(); const n = Wn(this), r = at(void 0); try { return t() } finally { Wn(n), at(r) } } get(t, n = Gr, r = A.Default) { this.assertNotDestroyed(), r = ci(r); const o = Wn(this), i = at(void 0); try { if (!(r & A.SkipSelf)) { let a = this.records.get(t); if (void 0 === a) { const u = function lE(e) { return "function" == typeof e || "object" == typeof e && e instanceof x }(t) && ai(t); a = u && this.injectableDefInScope(u) ? cr(Tu(t), Ui) : null, this.records.set(t, a) } if (null != a) return this.hydrate(t, a) } return (r & A.Self ? Bi() : this.parent).get(t, n = r & A.Optional && n === Gr ? null : n) } catch (s) { if ("NullInjectorError" === s.name) { if ((s[li] = s[li] || []).unshift(J(t)), o) throw s; return function Nw(e, t, n, r) { const o = e[li]; throw t[Id] && o.unshift(t[Id]), e.message = function Ow(e, t, n, r = null) { e = e && "\n" === e.charAt(0) && e.charAt(1) == Rw ? e.slice(2) : e; let o = J(t); if (Array.isArray(t)) o = t.map(J).join(" -> "); else if ("object" == typeof t) { let i = []; for (let s in t) if (t.hasOwnProperty(s)) { let a = t[s]; i.push(s + ":" + ("string" == typeof a ? JSON.stringify(a) : J(a))) } o = `{${i.join(", ")}}` } return `${n}${r ? "(" + r + ")" : ""}[${o}]: ${e.replace(Aw, "\n  ")}` }("\n" + e.message, o, n, r), e[Tw] = o, e[li] = null, e }(s, t, "R3InjectorError", this.source) } throw s } finally { at(i), Wn(o) } } resolveInjectorInitializers() { const t = Wn(this), n = at(void 0); try { const r = this.get(Vi.multi, W, A.Self); for (const o of r) o() } finally { Wn(t), at(n) } } toString() { const t = [], n = this.records; for (const r of n.keys()) t.push(J(r)); return `R3Injector[${t.join(", ")}]` } assertNotDestroyed() { if (this._destroyed) throw new w(205, !1) } processProvider(t) { let n = Pn(t = T(t)) ? t : T(t && t.provide); const r = function sE(e) { return Su(e) ? cr(void 0, e.useValue) : cr(function Sh(e, t, n) { let r; if (Pn(e)) { const o = T(e); return In(o) || Tu(o) } if (Su(e)) r = () => T(e.useValue); else if (function Eh(e) { return !(!e || !e.useFactory) }(e)) r = () => e.useFactory(...ba(e.deps || [])); else if (function _h(e) { return !(!e || !e.useExisting) }(e)) r = () => R(T(e.useExisting)); else { const o = T(e && (e.useClass || e.provide)); if (!function aE(e) { return !!e.deps }(e)) return In(o) || Tu(o); r = () => new o(...ba(e.deps)) } return r }(e), Ui) }(t); if (Pn(t) || !0 !== t.multi) this.records.get(n); else { let o = this.records.get(n); o || (o = cr(void 0, Ui, !0), o.factory = () => ba(o.multi), this.records.set(n, o)), n = t, o.multi.push(t) } this.records.set(n, r) } hydrate(t, n) { return n.value === Ui && (n.value = oE, n.value = n.factory()), "object" == typeof n.value && n.value && function uE(e) { return null !== e && "object" == typeof e && "function" == typeof e.ngOnDestroy }(n.value) && this._ngOnDestroyHooks.add(n.value), n.value } injectableDefInScope(t) { if (!t.providedIn) return !1; const n = T(t.providedIn); return "string" == typeof n ? "any" === n || this.scopes.has(n) : this.injectorDefTypes.has(n) } } function Tu(e) { const t = ai(e), n = null !== t ? t.factory : In(e); if (null !== n) return n; if (e instanceof x) throw new w(204, !1); if (e instanceof Function) return function iE(e) { const t = e.length; if (t > 0) throw function io(e, t) { const n = []; for (let r = 0; r < e; r++)n.push(t); return n }(t, "?"), new w(204, !1); const n = function Sw(e) { return e && (e[ui] || e[bd]) || null }(e); return null !== n ? () => n.factory(e) : () => new e }(e); throw new w(204, !1) } function cr(e, t, n = !1) { return { factory: e, value: t, multi: n ? [] : void 0 } } function Au(e, t) { for (const n of e) Array.isArray(n) ? Au(n, t) : n && wa(n) ? Au(n.\u0275providers, t) : t(n) } class cE { } class Ih { } class fE { resolveComponentFactory(t) { throw function dE(e) { const t = Error(`No component factory found for ${J(e)}. Did you add it to @NgModule.entryComponents?`); return t.ngComponent = e, t }(t) } } let yo = (() => { class e { } return e.NULL = new fE, e })(); function hE() { return dr(Ie(), v()) } function dr(e, t) { return new dn(et(e, t)) } let dn = (() => { class e { constructor(n) { this.nativeElement = n } } return e.__NG_ELEMENT_ID__ = hE, e })(); class Th { } let Hi = (() => { class e { } return e.__NG_ELEMENT_ID__ = () => function gE() { const e = v(), n = Ge(Ie().index, e); return (Je(n) ? n : e)[V] }(), e })(), mE = (() => { class e { } return e.\u0275prov = N({ token: e, providedIn: "root", factory: () => null }), e })(); class zi { constructor(t) { this.full = t, this.major = t.split(".")[0], this.minor = t.split(".")[1], this.patch = t.split(".").slice(2).join(".") } } const yE = new zi("15.2.10"), Ru = {}, xu = "ngOriginalError"; function Pu(e) { return e[xu] } class fr { constructor() { this._console = console } handleError(t) { const n = this._findOriginalError(t); this._console.error("ERROR", t), n && this._console.error("ORIGINAL ERROR", n) } _findOriginalError(t) { let n = t && Pu(t); for (; n && Pu(n);)n = Pu(n); return n || null } } function Qt(e) { return e instanceof Function ? e() : e } function Rh(e, t, n) { let r = e.length; for (; ;) { const o = e.indexOf(t, n); if (-1 === o) return o; if (0 === o || e.charCodeAt(o - 1) <= 32) { const i = t.length; if (o + i === r || e.charCodeAt(o + i) <= 32) return o } n = o + 1 } } const xh = "ng-template"; function TE(e, t, n) { let r = 0, o = !0; for (; r < e.length;) { let i = e[r++]; if ("string" == typeof i && o) { const s = e[r++]; if (n && "class" === i && -1 !== Rh(s.toLowerCase(), t, 0)) return !0 } else { if (1 === i) { for (; r < e.length && "string" == typeof (i = e[r++]);)if (i.toLowerCase() === t) return !0; return !1 } "number" == typeof i && (o = !1) } } return !1 } function Ph(e) { return 4 === e.type && e.value !== xh } function AE(e, t, n) { return t === (4 !== e.type || n ? e.value : xh) } function RE(e, t, n) { let r = 4; const o = e.attrs || [], i = function NE(e) { for (let t = 0; t < e.length; t++)if (rf(e[t])) return t; return e.length }(o); let s = !1; for (let a = 0; a < t.length; a++) { const u = t[a]; if ("number" != typeof u) { if (!s) if (4 & r) { if (r = 2 | 1 & r, "" !== u && !AE(e, u, n) || "" === u && 1 === t.length) { if (vt(r)) return !1; s = !0 } } else { const l = 8 & r ? u : t[++a]; if (8 & r && null !== e.attrs) { if (!TE(e.attrs, l, n)) { if (vt(r)) return !1; s = !0 } continue } const d = xE(8 & r ? "class" : u, o, Ph(e), n); if (-1 === d) { if (vt(r)) return !1; s = !0; continue } if ("" !== l) { let f; f = d > i ? "" : o[d + 1].toLowerCase(); const h = 8 & r ? f : null; if (h && -1 !== Rh(h, l, 0) || 2 & r && l !== f) { if (vt(r)) return !1; s = !0 } } } } else { if (!s && !vt(r) && !vt(u)) return !1; if (s && vt(u)) continue; s = !1, r = u | 1 & r } } return vt(r) || s } function vt(e) { return 0 == (1 & e) } function xE(e, t, n, r) { if (null === t) return -1; let o = 0; if (r || !n) { let i = !1; for (; o < t.length;) { const s = t[o]; if (s === e) return o; if (3 === s || 6 === s) i = !0; else { if (1 === s || 2 === s) { let a = t[++o]; for (; "string" == typeof a;)a = t[++o]; continue } if (4 === s) break; if (0 === s) { o += 4; continue } } o += i ? 1 : 2 } return -1 } return function OE(e, t) { let n = e.indexOf(4); if (n > -1) for (n++; n < e.length;) { const r = e[n]; if ("number" == typeof r) return -1; if (r === t) return n; n++ } return -1 }(t, e) } function Nh(e, t, n = !1) { for (let r = 0; r < t.length; r++)if (RE(e, t[r], n)) return !0; return !1 } function Oh(e, t) { return e ? ":not(" + t.trim() + ")" : t } function kE(e) { let t = e[0], n = 1, r = 2, o = "", i = !1; for (; n < e.length;) { let s = e[n]; if ("string" == typeof s) if (2 & r) { const a = e[++n]; o += "[" + s + (a.length > 0 ? '="' + a + '"' : "") + "]" } else 8 & r ? o += "." + s : 4 & r && (o += " " + s); else "" !== o && !vt(s) && (t += Oh(i, o), o = ""), r = s, i = i || !vt(r); n++ } return "" !== o && (t += Oh(i, o)), t } const k = {}; function Ve(e) { Fh(G(), v(), $e() + e, !1) } function Fh(e, t, n, r) { if (!r) if (3 == (3 & t[j])) { const i = e.preOrderCheckHooks; null !== i && Ci(t, i, n) } else { const i = e.preOrderHooks; null !== i && _i(t, i, 0, n) } Tn(n) } function $h(e, t = null, n = null, r) { const o = Vh(e, t, n, r); return o.resolveInjectorInitializers(), o } function Vh(e, t = null, n = null, r, o = new Set) { const i = [n || W, tE(e)]; return r = r || ("object" == typeof e ? void 0 : J(e)), new bh(i, t || Bi(), r || null, o) } let Kt = (() => { class e { static create(n, r) { if (Array.isArray(n)) return $h({ name: "" }, r, n, ""); { const o = n.name ?? ""; return $h({ name: o }, n.parent, n.providers, o) } } } return e.THROW_IF_NOT_FOUND = Gr, e.NULL = new Dh, e.\u0275prov = N({ token: e, providedIn: "any", factory: () => R(yh) }), e.__NG_ELEMENT_ID__ = -1, e })(); function S(e, t = A.Default) { const n = v(); return null === n ? R(e, t) : pf(Ie(), n, T(e), t) } function Zh(e, t) { const n = e.contentQueries; if (null !== n) for (let r = 0; r < n.length; r += 2) { const i = n[r + 1]; if (-1 !== i) { const s = e.data[i]; ka(n[r]), s.contentQueries(2, t[i], i) } } } function Wi(e, t, n, r, o, i, s, a, u, l, c) { const d = t.blueprint.slice(); return d[Gt] = o, d[j] = 76 | r, (null !== c || e && 1024 & e[j]) && (d[j] |= 1024), Hd(d), d[ae] = d[Yn] = e, d[le] = n, d[pi] = s || e && e[pi], d[V] = a || e && e[V], d[Ma] = u || e && e[Ma] || null, d[hi] = l || e && e[hi] || null, d[Ae] = i, d[Xr] = function n_() { return t_++ }(), d[Nd] = c, d[Re] = 2 == t.type ? e[Re] : d, d } function gr(e, t, n, r, o) { let i = e.data[t]; if (null === i) i = function Lu(e, t, n, r, o) { const i = Wd(), s = Pa(), u = e.data[t] = function l0(e, t, n, r, o, i) { return { type: n, index: r, insertBeforeIndex: null, injectorIndex: t ? t.injectorIndex : -1, directiveStart: -1, directiveEnd: -1, directiveStylingLast: -1, componentOffset: -1, propertyBindings: null, flags: 0, providerIndexes: 0, value: o, attrs: i, mergedAttrs: null, localNames: null, initialInputs: void 0, inputs: null, outputs: null, tView: null, next: null, prev: null, projectionNext: null, child: null, parent: t, projection: null, styles: null, stylesWithoutHost: null, residualStyles: void 0, classes: null, classesWithoutHost: null, residualClasses: void 0, classBindings: 0, styleBindings: 0 } }(0, s ? i : i && i.parent, n, t, r, o); return null === e.firstChild && (e.firstChild = u), null !== i && (s ? null == i.child && null !== u.parent && (i.child = u) : null === i.next && (i.next = u, u.prev = i)), u }(e, t, n, r, o), function sC() { return F.lFrame.inI18n }() && (i.flags |= 32); else if (64 & i.type) { i.type = n, i.value = r, i.attrs = o; const s = function eo() { const e = F.lFrame, t = e.currentTNode; return e.isParent ? t : t.parent }(); i.injectorIndex = null === s ? -1 : s.injectorIndex } return Rt(i, !0), i } function vo(e, t, n, r) { if (0 === n) return -1; const o = t.length; for (let i = 0; i < n; i++)t.push(r), e.blueprint.push(r), e.data.push(null); return o } function ju(e, t, n) { La(t); try { const r = e.viewQuery; null !== r && qu(1, r, n); const o = e.template; null !== o && Yh(e, t, o, 1, n), e.firstCreatePass && (e.firstCreatePass = !1), e.staticContentQueries && Zh(e, t), e.staticViewQueries && qu(2, e.viewQuery, n); const i = e.components; null !== i && function s0(e, t) { for (let n = 0; n < t.length; n++)A0(e, t[n]) }(t, i) } catch (r) { throw e.firstCreatePass && (e.incompleteFirstPass = !0, e.firstCreatePass = !1), r } finally { t[j] &= -5, ja() } } function qi(e, t, n, r) { const o = t[j]; if (128 != (128 & o)) { La(t); try { Hd(t), function Zd(e) { return F.lFrame.bindingIndex = e }(e.bindingStartIndex), null !== n && Yh(e, t, n, 2, r); const s = 3 == (3 & o); if (s) { const l = e.preOrderCheckHooks; null !== l && Ci(t, l, null) } else { const l = e.preOrderHooks; null !== l && _i(t, l, 0, null), $a(t, 0) } if (function M0(e) { for (let t = su(e); null !== t; t = au(t)) { if (!t[Od]) continue; const n = t[Kn]; for (let r = 0; r < n.length; r++) { const o = n[r]; 512 & o[j] || xa(o[ae], 1), o[j] |= 512 } } }(t), function I0(e) { for (let t = su(e); null !== t; t = au(t))for (let n = Le; n < t.length; n++) { const r = t[n], o = r[E]; Di(r) && qi(o, r, o.template, r[le]) } }(t), null !== e.contentQueries && Zh(e, t), s) { const l = e.contentCheckHooks; null !== l && Ci(t, l) } else { const l = e.contentHooks; null !== l && _i(t, l, 1), $a(t, 1) } !function r0(e, t) { const n = e.hostBindingOpCodes; if (null !== n) try { for (let r = 0; r < n.length; r++) { const o = n[r]; if (o < 0) Tn(~o); else { const i = o, s = n[++r], a = n[++r]; aC(s, i), a(2, t[i]) } } } finally { Tn(-1) } }(e, t); const a = e.components; null !== a && function o0(e, t) { for (let n = 0; n < t.length; n++)T0(e, t[n]) }(t, a); const u = e.viewQuery; if (null !== u && qu(2, u, r), s) { const l = e.viewCheckHooks; null !== l && Ci(t, l) } else { const l = e.viewHooks; null !== l && _i(t, l, 2), $a(t, 2) } !0 === e.firstUpdatePass && (e.firstUpdatePass = !1), t[j] &= -41, 512 & t[j] && (t[j] &= -513, xa(t[ae], -1)) } finally { ja() } } } function Yh(e, t, n, r, o) { const i = $e(), s = 2 & r; try { Tn(-1), s && t.length > ne && Fh(e, t, ne, !1), ut(s ? 2 : 0, o), n(r, o) } finally { Tn(i), ut(s ? 3 : 1, o) } } function $u(e, t, n) { if (Aa(t)) { const o = t.directiveEnd; for (let i = t.directiveStart; i < o; i++) { const s = e.data[i]; s.contentQueries && s.contentQueries(1, n[i], i) } } } function Qh(e) { const t = e.tView; return null === t || t.incompleteFirstPass ? e.tView = Bu(1, null, e.template, e.decls, e.vars, e.directiveDefs, e.pipeDefs, e.viewQuery, e.schemas, e.consts) : t } function Bu(e, t, n, r, o, i, s, a, u, l) { const c = ne + r, d = c + o, f = function a0(e, t) { const n = []; for (let r = 0; r < t; r++)n.push(r < e ? null : k); return n }(c, d), h = "function" == typeof l ? l() : l; return f[E] = { type: e, blueprint: f, template: n, queries: null, viewQuery: a, declTNode: t, data: f.slice().fill(null, c), bindingStartIndex: c, expandoStartIndex: d, hostBindingOpCodes: null, firstCreatePass: !0, firstUpdatePass: !0, staticViewQueries: !1, staticContentQueries: !1, preOrderHooks: null, preOrderCheckHooks: null, contentHooks: null, contentCheckHooks: null, viewHooks: null, viewCheckHooks: null, destroyHooks: null, cleanup: null, contentQueries: null, components: null, directiveRegistry: "function" == typeof i ? i() : i, pipeRegistry: "function" == typeof s ? s() : s, firstChild: null, schemas: u, consts: h, incompleteFirstPass: !1 } } function Xh(e, t, n, r) { for (let o in e) if (e.hasOwnProperty(o)) { n = null === n ? {} : n; const i = e[o]; null === r ? Jh(n, t, o, i) : r.hasOwnProperty(o) && Jh(n, t, r[o], i) } return n } function Jh(e, t, n, r) { e.hasOwnProperty(n) ? e[n].push(t, r) : e[n] = [t, r] } function ep(e, t, n, r, o, i) { for (let l = 0; l < r.length; l++)Ga(Ii(n, t), e, r[l].type); !function C0(e, t, n) { e.flags |= 1, e.directiveStart = t, e.directiveEnd = t + n, e.providerIndexes = t }(n, e.data.length, r.length); for (let l = 0; l < r.length; l++) { const c = r[l]; c.providersResolver && c.providersResolver(c) } let s = !1, a = !1, u = vo(e, t, r.length, null); for (let l = 0; l < r.length; l++) { const c = r[l]; n.mergedAttrs = no(n.mergedAttrs, c.hostAttrs), _0(e, n, t, u, c), w0(u, c, o), null !== c.contentQueries && (n.flags |= 4), (null !== c.hostBindings || null !== c.hostAttrs || 0 !== c.hostVars) && (n.flags |= 64); const d = c.type.prototype; !s && (d.ngOnChanges || d.ngOnInit || d.ngDoCheck) && ((e.preOrderHooks ?? (e.preOrderHooks = [])).push(n.index), s = !0), !a && (d.ngOnChanges || d.ngDoCheck) && ((e.preOrderCheckHooks ?? (e.preOrderCheckHooks = [])).push(n.index), a = !0), u++ } !function c0(e, t, n) { const o = t.directiveEnd, i = e.data, s = t.attrs, a = []; let u = null, l = null; for (let c = t.directiveStart; c < o; c++) { const d = i[c], f = n ? n.get(d) : null, p = f ? f.outputs : null; u = Xh(d.inputs, c, u, f ? f.inputs : null), l = Xh(d.outputs, c, l, p); const g = null === u || null === s || Ph(t) ? null : S0(u, c, s); a.push(g) } null !== u && (u.hasOwnProperty("class") && (t.flags |= 8), u.hasOwnProperty("style") && (t.flags |= 16)), t.initialInputs = a, t.inputs = u, t.outputs = l }(e, n, i) } function tp(e, t, n) { const r = n.directiveStart, o = n.directiveEnd, i = n.index, s = function uC() { return F.lFrame.currentDirectiveIndex }(); try { Tn(i); for (let a = r; a < o; a++) { const u = e.data[a], l = t[a]; Oa(a), (null !== u.hostBindings || 0 !== u.hostVars || null !== u.hostAttrs) && y0(u, l) } } finally { Tn(-1), Oa(s) } } function y0(e, t) { null !== e.hostBindings && e.hostBindings(1, t) } function zu(e, t, n) { t.componentOffset = n, (e.components ?? (e.components = [])).push(t.index) } function w0(e, t, n) { if (n) { if (t.exportAs) for (let r = 0; r < t.exportAs.length; r++)n[t.exportAs[r]] = e; yt(t) && (n[""] = e) } } function _0(e, t, n, r, o) { e.data[r] = o; const i = o.factory || (o.factory = In(o.type)), s = new to(i, yt(o), S); e.blueprint[r] = s, n[r] = s, function p0(e, t, n, r, o) { const i = o.hostBindings; if (i) { let s = e.hostBindingOpCodes; null === s && (s = e.hostBindingOpCodes = []); const a = ~t.index; (function g0(e) { let t = e.length; for (; t > 0;) { const n = e[--t]; if ("number" == typeof n && n < 0) return n } return 0 })(s) != a && s.push(a), s.push(n, r, i) } }(e, t, r, vo(e, n, o.hostVars, k), o) } function Pt(e, t, n, r, o, i) { const s = et(e, t); !function Gu(e, t, n, r, o, i, s) { if (null == i) e.removeAttribute(t, o, n); else { const a = null == s ? O(i) : s(i, r || "", o); e.setAttribute(t, o, a, n) } }(t[V], s, i, e.value, n, r, o) } function b0(e, t, n, r, o, i) { const s = i[t]; if (null !== s) { const a = r.setInput; for (let u = 0; u < s.length;) { const l = s[u++], c = s[u++], d = s[u++]; null !== a ? r.setInput(n, d, l, c) : n[c] = d } } } function S0(e, t, n) { let r = null, o = 0; for (; o < n.length;) { const i = n[o]; if (0 !== i) if (5 !== i) { if ("number" == typeof i) break; if (e.hasOwnProperty(i)) { null === r && (r = []); const s = e[i]; for (let a = 0; a < s.length; a += 2)if (s[a] === t) { r.push(i, s[a + 1], n[o + 1]); break } } o += 2 } else o += 2; else o += 4 } return r } function T0(e, t) { const n = Ge(t, e); if (Di(n)) { const r = n[E]; 48 & n[j] ? qi(r, n, r.template, n[le]) : n[Sn] > 0 && Wu(n) } } function Wu(e) { for (let r = su(e); null !== r; r = au(r))for (let o = Le; o < r.length; o++) { const i = r[o]; if (Di(i)) if (512 & i[j]) { const s = i[E]; qi(s, i, s.template, i[le]) } else i[Sn] > 0 && Wu(i) } const n = e[E].components; if (null !== n) for (let r = 0; r < n.length; r++) { const o = Ge(n[r], e); Di(o) && o[Sn] > 0 && Wu(o) } } function A0(e, t) { const n = Ge(t, e), r = n[E]; (function R0(e, t) { for (let n = t.length; n < e.blueprint.length; n++)t.push(e.blueprint[n]) })(r, n), ju(r, n, n[le]) } function Zi(e, t) { return e[Qr] ? e[Pd][gt] = t : e[Qr] = t, e[Pd] = t, t } function Yi(e) { for (; e;) { e[j] |= 32; const t = fo(e); if (Vw(e) && !t) return e; e = t } return null } function Qi(e, t, n, r = !0) { const o = t[pi]; o.begin && o.begin(); try { qi(e, t, e.template, n) } catch (s) { throw r && sp(t, s), s } finally { o.end && o.end() } } function qu(e, t, n) { ka(0), t(e, n) } function rp(e) { return e[Zn] || (e[Zn] = []) } function op(e) { return e.cleanup || (e.cleanup = []) } function sp(e, t) { const n = e[hi], r = n ? n.get(fr, null) : null; r && r.handleError(t) } function Zu(e, t, n, r, o) { for (let i = 0; i < n.length;) { const s = n[i++], a = n[i++], u = t[s], l = e.data[s]; null !== l.setInput ? l.setInput(u, o, r, a) : u[a] = o } } function Ki(e, t, n) { let r = n ? e.styles : null, o = n ? e.classes : null, i = 0; if (null !== t) for (let s = 0; s < t.length; s++) { const a = t[s]; "number" == typeof a ? i = a : 1 == i ? o = ya(o, a) : 2 == i && (r = ya(r, a + ": " + t[++s] + ";")) } n ? e.styles = r : e.stylesWithoutHost = r, n ? e.classes = o : e.classesWithoutHost = o } function Xi(e, t, n, r, o = !1) { for (; null !== n;) { const i = t[n.index]; if (null !== i && r.push(Se(i)), mt(i)) for (let a = Le; a < i.length; a++) { const u = i[a], l = u[E].firstChild; null !== l && Xi(u[E], u, l, r) } const s = n.type; if (8 & s) Xi(e, t, n.child, r); else if (32 & s) { const a = iu(n, t); let u; for (; u = a();)r.push(u) } else if (16 & s) { const a = eh(t, n); if (Array.isArray(a)) r.push(...a); else { const u = fo(t[Re]); Xi(u[E], u, a, r, !0) } } n = o ? n.projectionNext : n.next } return r } class Do { get rootNodes() { const t = this._lView, n = t[E]; return Xi(n, t, n.firstChild, []) } constructor(t, n) { this._lView = t, this._cdRefInjectingView = n, this._appRef = null, this._attachedToViewContainer = !1 } get context() { return this._lView[le] } set context(t) { this._lView[le] = t } get destroyed() { return 128 == (128 & this._lView[j]) } destroy() { if (this._appRef) this._appRef.detachView(this); else if (this._attachedToViewContainer) { const t = this._lView[ae]; if (mt(t)) { const n = t[mi], r = n ? n.indexOf(this) : -1; r > -1 && (cu(t, r), Ai(n, r)) } this._attachedToViewContainer = !1 } Gf(this._lView[E], this._lView) } onDestroy(t) { !function Kh(e, t, n, r) { const o = rp(t); null === n ? o.push(r) : (o.push(n), e.firstCreatePass && op(e).push(r, o.length - 1)) }(this._lView[E], this._lView, null, t) } markForCheck() { Yi(this._cdRefInjectingView || this._lView) } detach() { this._lView[j] &= -65 } reattach() { this._lView[j] |= 64 } detectChanges() { Qi(this._lView[E], this._lView, this.context) } checkNoChanges() { } attachToViewContainerRef() { if (this._appRef) throw new w(902, !1); this._attachedToViewContainer = !0 } detachFromAppRef() { this._appRef = null, function y_(e, t) { ho(e, t, t[V], 2, null, null) }(this._lView[E], this._lView) } attachToAppRef(t) { if (this._attachedToViewContainer) throw new w(902, !1); this._appRef = t } } class x0 extends Do { constructor(t) { super(t), this._view = t } detectChanges() { const t = this._view; Qi(t[E], t, t[le], !1) } checkNoChanges() { } get context() { return null } } class ap extends yo { constructor(t) { super(), this.ngModule = t } resolveComponentFactory(t) { const n = Q(t); return new wo(n, this.ngModule) } } function up(e) { const t = []; for (let n in e) e.hasOwnProperty(n) && t.push({ propName: e[n], templateName: n }); return t } class N0 { constructor(t, n) { this.injector = t, this.parentInjector = n } get(t, n, r) { r = ci(r); const o = this.injector.get(t, Ru, r); return o !== Ru || n === Ru ? o : this.parentInjector.get(t, n, r) } } class wo extends Ih { get inputs() { return up(this.componentDef.inputs) } get outputs() { return up(this.componentDef.outputs) } constructor(t, n) { super(), this.componentDef = t, this.ngModule = n, this.componentType = t.type, this.selector = function LE(e) { return e.map(kE).join(",") }(t.selectors), this.ngContentSelectors = t.ngContentSelectors ? t.ngContentSelectors : [], this.isBoundToModule = !!n } create(t, n, r, o) { let i = (o = o || this.ngModule) instanceof Yt ? o : o?.injector; i && null !== this.componentDef.getStandaloneInjector && (i = this.componentDef.getStandaloneInjector(i) || i); const s = i ? new N0(t, i) : t, a = s.get(Th, null); if (null === a) throw new w(407, !1); const u = s.get(mE, null), l = a.createRenderer(null, this.componentDef), c = this.componentDef.selectors[0][0] || "div", d = r ? function u0(e, t, n) { return e.selectRootElement(t, n === Tt.ShadowDom) }(l, r, this.componentDef.encapsulation) : lu(l, c, function P0(e) { const t = e.toLowerCase(); return "svg" === t ? "svg" : "math" === t ? "math" : null }(c)), f = this.componentDef.onPush ? 288 : 272, h = Bu(0, null, null, 1, 0, null, null, null, null, null), p = Wi(null, h, null, f, null, null, a, l, u, s, null); let g, y; La(p); try { const D = this.componentDef; let _, m = null; D.findHostDirectiveDefs ? (_ = [], m = new Map, D.findHostDirectiveDefs(D, _, m), _.push(D)) : _ = [D]; const b = function F0(e, t) { const n = e[E], r = ne; return e[r] = t, gr(n, r, 2, "#host", null) }(p, d), q = function k0(e, t, n, r, o, i, s, a) { const u = o[E]; !function L0(e, t, n, r) { for (const o of e) t.mergedAttrs = no(t.mergedAttrs, o.hostAttrs); null !== t.mergedAttrs && (Ki(t, t.mergedAttrs, !0), null !== n && rh(r, n, t)) }(r, e, t, s); const l = i.createRenderer(t, n), c = Wi(o, Qh(n), null, n.onPush ? 32 : 16, o[e.index], e, i, l, a || null, null, null); return u.firstCreatePass && zu(u, e, r.length - 1), Zi(o, c), o[e.index] = c }(b, d, D, _, p, a, l); y = Bd(h, ne), d && function $0(e, t, n, r) { if (r) Ua(e, n, ["ng-version", yE.full]); else { const { attrs: o, classes: i } = function jE(e) { const t = [], n = []; let r = 1, o = 2; for (; r < e.length;) { let i = e[r]; if ("string" == typeof i) 2 === o ? "" !== i && t.push(i, e[++r]) : 8 === o && n.push(i); else { if (!vt(o)) break; o = i } r++ } return { attrs: t, classes: n } }(t.selectors[0]); o && Ua(e, n, o), i && i.length > 0 && nh(e, n, i.join(" ")) } }(l, D, d, r), void 0 !== n && function V0(e, t, n) { const r = e.projection = []; for (let o = 0; o < t.length; o++) { const i = n[o]; r.push(null != i ? Array.from(i) : null) } }(y, this.ngContentSelectors, n), g = function j0(e, t, n, r, o, i) { const s = Ie(), a = o[E], u = et(s, o); ep(a, o, s, n, null, r); for (let c = 0; c < n.length; c++)xe(An(o, a, s.directiveStart + c, s), o); tp(a, o, s), u && xe(u, o); const l = An(o, a, s.directiveStart + s.componentOffset, s); if (e[le] = o[le] = l, null !== i) for (const c of i) c(l, t); return $u(a, s, e), l }(q, D, _, m, p, [U0]), ju(h, p, null) } finally { ja() } return new O0(this.componentType, g, dr(y, p), p, y) } } class O0 extends cE { constructor(t, n, r, o, i) { super(), this.location = r, this._rootLView = o, this._tNode = i, this.instance = n, this.hostView = this.changeDetectorRef = new x0(o), this.componentType = t } setInput(t, n) { const r = this._tNode.inputs; let o; if (null !== r && (o = r[t])) { const i = this._rootLView; Zu(i[E], i, o, t, n), Yi(Ge(this._tNode.index, i)) } } get injector() { return new tr(this._tNode, this._rootLView) } destroy() { this.hostView.destroy() } onDestroy(t) { this.hostView.onDestroy(t) } } function U0() { const e = Ie(); wi(v()[E], e) } function Ji(e) { return !!Qu(e) && (Array.isArray(e) || !(e instanceof Map) && Symbol.iterator in e) } function Qu(e) { return null !== e && ("function" == typeof e || "object" == typeof e) } function Nt(e, t, n) { return e[t] = n } function Pe(e, t, n) { return !Object.is(e[t], n) && (e[t] = n, !0) } function Ku(e, t, n, r) { const o = v(); return Pe(o, Jn(), t) && (G(), Pt(oe(), o, e, t, n, r)), Ku } function rt(e, t, n) { const r = v(); return Pe(r, Jn(), t) && function nt(e, t, n, r, o, i, s, a) { const u = et(t, n); let c, l = t.inputs; !a && null != l && (c = l[r]) ? (Zu(e, n, c, r, o), Jr(t) && function f0(e, t) { const n = Ge(t, e); 16 & n[j] || (n[j] |= 32) }(n, t.index)) : 3 & t.type && (r = function d0(e) { return "class" === e ? "className" : "for" === e ? "htmlFor" : "formaction" === e ? "formAction" : "innerHtml" === e ? "innerHTML" : "readonly" === e ? "readOnly" : "tabindex" === e ? "tabIndex" : e }(r), o = null != s ? s(o, t.value || "", r) : o, i.setProperty(u, r, o)) }(G(), oe(), r, e, t, r[V], n, !1), rt } function Xu(e, t, n, r, o) { const s = o ? "class" : "style"; Zu(e, n, t.inputs[s], s, r) } function re(e, t, n, r) { const o = v(), i = G(), s = ne + e, a = o[V], u = i.firstCreatePass ? function ib(e, t, n, r, o, i) { const s = t.consts, u = gr(t, e, 2, r, ln(s, o)); return function Hu(e, t, n, r) { if (Gd()) { const o = null === r ? null : { "": -1 }, i = function v0(e, t) { const n = e.directiveRegistry; let r = null, o = null; if (n) for (let i = 0; i < n.length; i++) { const s = n[i]; if (Nh(t, s.selectors, !1)) if (r || (r = []), yt(s)) if (null !== s.findHostDirectiveDefs) { const a = []; o = o || new Map, s.findHostDirectiveDefs(s, a, o), r.unshift(...a, s), zu(e, t, a.length) } else r.unshift(s), zu(e, t, 0); else o = o || new Map, s.findHostDirectiveDefs?.(s, r, o), r.push(s) } return null === r ? null : [r, o] }(e, n); let s, a; null === i ? s = a = null : [s, a] = i, null !== s && ep(e, t, n, s, o, a), o && function D0(e, t, n) { if (t) { const r = e.localNames = []; for (let o = 0; o < t.length; o += 2) { const i = n[t[o + 1]]; if (null == i) throw new w(-301, !1); r.push(t[o], i) } } }(n, r, o) } n.mergedAttrs = no(n.mergedAttrs, n.attrs) }(t, n, u, ln(s, i)), null !== u.attrs && Ki(u, u.attrs, !1), null !== u.mergedAttrs && Ki(u, u.mergedAttrs, !0), null !== t.queries && t.queries.elementStart(t, u), u }(s, i, o, t, n, r) : i.data[s], l = o[s] = lu(a, t, function mC() { return F.lFrame.currentNamespace }()), c = yi(u); return Rt(u, !0), rh(a, l, u), 32 != (32 & u.flags) && Oi(i, o, l, u), 0 === function Xw() { return F.lFrame.elementDepthCount }() && xe(l, o), function Jw() { F.lFrame.elementDepthCount++ }(), c && (function Vu(e, t, n) { Gd() && (function m0(e, t, n, r) { const o = n.directiveStart, i = n.directiveEnd; Jr(n) && function E0(e, t, n) { const r = et(t, e), o = Qh(n), i = e[pi], s = Zi(e, Wi(e, o, null, n.onPush ? 32 : 16, r, t, i, i.createRenderer(r, n), null, null, null)); e[t.index] = s }(t, n, e.data[o + n.componentOffset]), e.firstCreatePass || Ii(n, t), xe(r, t); const s = n.initialInputs; for (let a = o; a < i; a++) { const u = e.data[a], l = An(t, e, a, n); xe(l, t), null !== s && b0(0, a - o, l, u, 0, s), yt(u) && (Ge(n.index, t)[le] = An(t, e, a, n)) } }(e, t, n, et(n, t)), 64 == (64 & n.flags) && tp(e, t, n)) }(i, o, u), $u(i, u, o)), null !== r && function Uu(e, t, n = et) { const r = t.localNames; if (null !== r) { let o = t.index + 1; for (let i = 0; i < r.length; i += 2) { const s = r[i + 1], a = -1 === s ? n(t, e) : e[s]; e[o++] = a } } }(o, u), re } function ie() { let e = Ie(); Pa() ? function Na() { F.lFrame.isParent = !1 }() : (e = e.parent, Rt(e, !1)); const t = e; !function eC() { F.lFrame.elementDepthCount-- }(); const n = G(); return n.firstCreatePass && (wi(n, e), Aa(e) && n.queries.elementEnd(e)), null != t.classesWithoutHost && function wC(e) { return 0 != (8 & e.flags) }(t) && Xu(n, t, v(), t.classesWithoutHost, !0), null != t.stylesWithoutHost && function CC(e) { return 0 != (16 & e.flags) }(t) && Xu(n, t, v(), t.stylesWithoutHost, !1), ie } function Ne(e, t, n, r) { return re(e, t, n, r), ie(), Ne } function ts(e) { return !!e && "function" == typeof e.then } const Sp = function bp(e) { return !!e && "function" == typeof e.subscribe }; function On(e, t, n, r) { const o = v(), i = G(), s = Ie(); return function Mp(e, t, n, r, o, i, s) { const a = yi(r), l = e.firstCreatePass && op(e), c = t[le], d = rp(t); let f = !0; if (3 & r.type || s) { const g = et(r, t), y = s ? s(g) : g, D = d.length, _ = s ? b => s(Se(b[r.index])) : r.index; let m = null; if (!s && a && (m = function ub(e, t, n, r) { const o = e.cleanup; if (null != o) for (let i = 0; i < o.length - 1; i += 2) { const s = o[i]; if (s === n && o[i + 1] === r) { const a = t[Zn], u = o[i + 2]; return a.length > u ? a[u] : null } "string" == typeof s && (i += 2) } return null }(e, t, o, r.index)), null !== m) (m.__ngLastListenerFn__ || m).__ngNextListenerFn__ = i, m.__ngLastListenerFn__ = i, f = !1; else { i = Ap(r, t, c, i, !1); const b = n.listen(y, o, i); d.push(i, b), l && l.push(o, _, D, D + 1) } } else i = Ap(r, t, c, i, !1); const h = r.outputs; let p; if (f && null !== h && (p = h[o])) { const g = p.length; if (g) for (let y = 0; y < g; y += 2) { const q = t[p[y]][p[y + 1]].subscribe(i), he = d.length; d.push(i, q), l && l.push(o, r.index, he, -(he + 1)) } } }(i, o, o[V], s, e, t, r), On } function Tp(e, t, n, r) { try { return ut(6, t, n), !1 !== n(r) } catch (o) { return sp(e, o), !1 } finally { ut(7, t, n) } } function Ap(e, t, n, r, o) { return function i(s) { if (s === Function) return r; Yi(e.componentOffset > -1 ? Ge(e.index, t) : t); let u = Tp(t, n, r, s), l = i.__ngNextListenerFn__; for (; l;)u = Tp(t, n, l, s) && u, l = l.__ngNextListenerFn__; return o && !1 === u && (s.preventDefault(), s.returnValue = !1), u } } function ns(e, t) { return e << 17 | t << 2 } function fn(e) { return e >> 17 & 32767 } function nl(e) { return 2 | e } function Fn(e) { return (131068 & e) >> 2 } function rl(e, t) { return -131069 & e | t << 2 } function ol(e) { return 1 | e } function $p(e, t, n, r, o) { const i = e[n + 1], s = null === t; let a = r ? fn(i) : Fn(i), u = !1; for (; 0 !== a && (!1 === u || s);) { const c = e[a + 1]; vb(e[a], t) && (u = !0, e[a + 1] = r ? ol(c) : nl(c)), a = r ? fn(c) : Fn(c) } u && (e[n + 1] = r ? nl(i) : ol(i)) } function vb(e, t) { return null === e || null == t || (Array.isArray(e) ? e[1] : e) === t || !(!Array.isArray(e) || "string" != typeof t) && sr(e, t) >= 0 } const we = { textEnd: 0, key: 0, keyEnd: 0, value: 0, valueEnd: 0 }; function Vp(e) { return e.substring(we.key, we.keyEnd) } function Up(e, t) { const n = we.textEnd; return n === t ? -1 : (t = we.keyEnd = function _b(e, t, n) { for (; t < n && e.charCodeAt(t) > 32;)t++; return t }(e, we.key = t, n), Sr(e, t, n)) } function Sr(e, t, n) { for (; t < n && e.charCodeAt(t) <= 32;)t++; return t } function rs(e) { !function wt(e, t, n, r) { const o = G(), i = function qt(e) { const t = F.lFrame, n = t.bindingIndex; return t.bindingIndex = t.bindingIndex + e, n }(2); o.firstUpdatePass && function Yp(e, t, n, r) { const o = e.data; if (null === o[n + 1]) { const i = o[$e()], s = Zp(e, n); Jp(i, r) && null === t && !s && (t = !1), t = function Ib(e, t, n, r) { const o = function Fa(e) { const t = F.lFrame.currentDirectiveIndex; return -1 === t ? null : e[t] }(e); let i = r ? t.residualClasses : t.residualStyles; if (null === o) 0 === (r ? t.classBindings : t.styleBindings) && (n = _o(n = il(null, e, t, n, r), t.attrs, r), i = null); else { const s = t.directiveStylingLast; if (-1 === s || e[s] !== o) if (n = il(o, e, t, n, r), null === i) { let u = function Mb(e, t, n) { const r = n ? t.classBindings : t.styleBindings; if (0 !== Fn(r)) return e[fn(r)] }(e, t, r); void 0 !== u && Array.isArray(u) && (u = il(null, e, t, u[1], r), u = _o(u, t.attrs, r), function Tb(e, t, n, r) { e[fn(n ? t.classBindings : t.styleBindings)] = r }(e, t, r, u)) } else i = function Ab(e, t, n) { let r; const o = t.directiveEnd; for (let i = 1 + t.directiveStylingLast; i < o; i++)r = _o(r, e[i].hostAttrs, n); return _o(r, t.attrs, n) }(e, t, r) } return void 0 !== i && (r ? t.residualClasses = i : t.residualStyles = i), n }(o, i, t, r), function mb(e, t, n, r, o, i) { let s = i ? t.classBindings : t.styleBindings, a = fn(s), u = Fn(s); e[r] = n; let c, l = !1; if (Array.isArray(n) ? (c = n[1], (null === c || sr(n, c) > 0) && (l = !0)) : c = n, o) if (0 !== u) { const f = fn(e[a + 1]); e[r + 1] = ns(f, a), 0 !== f && (e[f + 1] = rl(e[f + 1], r)), e[a + 1] = function pb(e, t) { return 131071 & e | t << 17 }(e[a + 1], r) } else e[r + 1] = ns(a, 0), 0 !== a && (e[a + 1] = rl(e[a + 1], r)), a = r; else e[r + 1] = ns(u, 0), 0 === a ? a = r : e[u + 1] = rl(e[u + 1], r), u = r; l && (e[r + 1] = nl(e[r + 1])), $p(e, c, r, !0), $p(e, c, r, !1), function yb(e, t, n, r, o) { const i = o ? e.residualClasses : e.residualStyles; null != i && "string" == typeof t && sr(i, t) >= 0 && (n[r + 1] = ol(n[r + 1])) }(t, c, e, r, i), s = ns(a, u), i ? t.classBindings = s : t.styleBindings = s }(o, i, t, n, s, r) } }(o, null, i, r); const s = v(); if (n !== k && Pe(s, i, n)) { const a = o.data[$e()]; if (Jp(a, r) && !Zp(o, i)) { let u = r ? a.classesWithoutHost : a.stylesWithoutHost; null !== u && (n = ya(u, n || "")), Xu(o, a, s, n, r) } else !function Pb(e, t, n, r, o, i, s, a) { o === k && (o = W); let u = 0, l = 0, c = 0 < o.length ? o[0] : null, d = 0 < i.length ? i[0] : null; for (; null !== c || null !== d;) { const f = u < o.length ? o[u + 1] : void 0, h = l < i.length ? i[l + 1] : void 0; let g, p = null; c === d ? (u += 2, l += 2, f !== h && (p = d, g = h)) : null === d || null !== c && c < d ? (u += 2, p = c) : (l += 2, p = d, g = h), null !== p && Kp(e, t, n, r, p, g, s, a), c = u < o.length ? o[u] : null, d = l < i.length ? i[l] : null } }(o, a, s, s[V], s[i + 1], s[i + 1] = function Rb(e, t, n) { if (null == n || "" === n) return W; const r = [], o = cn(n); if (Array.isArray(o)) for (let i = 0; i < o.length; i++)e(r, o[i], !0); else if ("object" == typeof o) for (const i in o) o.hasOwnProperty(i) && e(r, i, o[i]); else "string" == typeof o && t(r, o); return r }(e, t, n), r, i) } }(xb, Ft, e, !0) } function Ft(e, t) { for (let n = function wb(e) { return function Hp(e) { we.key = 0, we.keyEnd = 0, we.value = 0, we.valueEnd = 0, we.textEnd = e.length }(e), Up(e, Sr(e, 0, we.textEnd)) }(t); n >= 0; n = Up(t, n))tt(e, Vp(t), !0) } function Zp(e, t) { return t >= e.expandoStartIndex } function il(e, t, n, r, o) { let i = null; const s = n.directiveEnd; let a = n.directiveStylingLast; for (-1 === a ? a = n.directiveStart : a++; a < s && (i = t[a], r = _o(r, i.hostAttrs, o), i !== e);)a++; return null !== e && (n.directiveStylingLast = a), r } function _o(e, t, n) { const r = n ? 1 : 2; let o = -1; if (null !== t) for (let i = 0; i < t.length; i++) { const s = t[i]; "number" == typeof s ? o = s : o === r && (Array.isArray(e) || (e = void 0 === e ? [] : ["", e]), tt(e, s, !!n || t[++i])) } return void 0 === e ? null : e } function xb(e, t, n) { const r = String(t); "" !== r && !r.includes(" ") && tt(e, r, n) } function Kp(e, t, n, r, o, i, s, a) { if (!(3 & t.type)) return; const u = e.data, l = u[a + 1], c = function gb(e) { return 1 == (1 & e) }(l) ? Xp(u, t, n, o, Fn(l), s) : void 0; os(c) || (os(i) || function hb(e) { return 2 == (2 & e) }(l) && (i = Xp(u, null, n, o, a, s)), function M_(e, t, n, r, o) { if (t) o ? e.addClass(n, r) : e.removeClass(n, r); else { let i = -1 === r.indexOf("-") ? void 0 : We.DashCase; null == o ? e.removeStyle(n, r, i) : ("string" == typeof o && o.endsWith("!important") && (o = o.slice(0, -10), i |= We.Important), e.setStyle(n, r, o, i)) } }(r, s, vi($e(), n), o, i)) } function Xp(e, t, n, r, o, i) { const s = null === t; let a; for (; o > 0;) { const u = e[o], l = Array.isArray(u), c = l ? u[1] : u, d = null === c; let f = n[o + 1]; f === k && (f = d ? W : void 0); let h = d ? Ya(f, r) : c === r ? f : void 0; if (l && !os(h) && (h = Ya(u, r)), os(h) && (a = h, s)) return a; const p = e[o + 1]; o = s ? fn(p) : Fn(p) } if (null !== t) { let u = i ? t.residualClasses : t.residualStyles; null != u && (a = Ya(u, r)) } return a } function os(e) { return void 0 !== e } function Jp(e, t) { return 0 != (e.flags & (t ? 8 : 16)) } function kt(e, t = "") { const n = v(), r = G(), o = e + ne, i = r.firstCreatePass ? gr(r, o, 1, t, null) : r.data[o], s = n[o] = function uu(e, t) { return e.createText(t) }(n[V], t); Oi(r, n, s, i), Rt(i, !1) } function is(e) { return sl("", e, ""), is } function sl(e, t, n) { const r = v(), o = function yr(e, t, n, r) { return Pe(e, Jn(), n) ? t + O(n) + r : k }(r, e, t, n); return o !== k && function Xt(e, t, n) { const r = vi(t, e); !function Hf(e, t, n) { e.setValue(t, n) }(e[V], r, n) }(r, $e(), o), sl } const Mr = "en-US"; let Cg = Mr; class Tr { } class qg { } class Zg extends Tr { constructor(t, n) { super(), this._parent = n, this._bootstrapComponents = [], this.destroyCbs = [], this.componentFactoryResolver = new ap(this); const r = Xe(t); this._bootstrapComponents = Qt(r.bootstrap), this._r3Injector = Vh(t, n, [{ provide: Tr, useValue: this }, { provide: yo, useValue: this.componentFactoryResolver }], J(t), new Set(["environment"])), this._r3Injector.resolveInjectorInitializers(), this.instance = this._r3Injector.get(t) } get injector() { return this._r3Injector } destroy() { const t = this._r3Injector; !t.destroyed && t.destroy(), this.destroyCbs.forEach(n => n()), this.destroyCbs = null } onDestroy(t) { this.destroyCbs.push(t) } } class hl extends qg { constructor(t) { super(), this.moduleType = t } create(t) { return new Zg(this.moduleType, t) } } class eI extends Tr { constructor(t, n, r) { super(), this.componentFactoryResolver = new ap(this), this.instance = null; const o = new bh([...t, { provide: Tr, useValue: this }, { provide: yo, useValue: this.componentFactoryResolver }], n || Bi(), r, new Set(["environment"])); this.injector = o, o.resolveInjectorInitializers() } destroy() { this.injector.destroy() } onDestroy(t) { this.injector.onDestroy(t) } } function cs(e, t, n = null) { return new eI(e, t, n).injector } let tI = (() => { class e { constructor(n) { this._injector = n, this.cachedInjectors = new Map } getOrCreateStandaloneInjector(n) { if (!n.standalone) return null; if (!this.cachedInjectors.has(n.id)) { const r = wh(0, n.type), o = r.length > 0 ? cs([r], this._injector, `Standalone[${n.type.name}]`) : null; this.cachedInjectors.set(n.id, o) } return this.cachedInjectors.get(n.id) } ngOnDestroy() { try { for (const n of this.cachedInjectors.values()) null !== n && n.destroy() } finally { this.cachedInjectors.clear() } } } return e.\u0275prov = N({ token: e, providedIn: "environment", factory: () => new e(R(Yt)) }), e })(); function Yg(e) { e.getStandaloneInjector = t => t.get(tI).getOrCreateStandaloneInjector(e) } function ds(e, t, n) { const r = je() + e, o = v(); return o[r] === k ? Nt(o, r, n ? t.call(n) : t()) : function Co(e, t) { return e[t] }(o, r) } function gl(e, t, n, r) { return function nm(e, t, n, r, o, i) { const s = t + n; return Pe(e, s, o) ? Nt(e, s + 1, i ? r.call(i, o) : r(o)) : function To(e, t) { const n = e[t]; return n === k ? void 0 : n }(e, s + 1) }(v(), je(), e, t, n, r) } function ml(e) { return t => { setTimeout(e, void 0, t) } } const Oe = class SI extends Vt { constructor(t = !1) { super(), this.__isAsync = t } emit(t) { super.next(t) } subscribe(t, n, r) { let o = t, i = n || (() => null), s = r; if (t && "object" == typeof t) { const u = t; o = u.next?.bind(u), i = u.error?.bind(u), s = u.complete?.bind(u) } this.__isAsync && (i = ml(i), o && (o = ml(o)), s && (s = ml(s))); const a = super.subscribe({ next: o, error: i, complete: s }); return t instanceof it && t.add(a), a } }; let Ct = (() => { class e { } return e.__NG_ELEMENT_ID__ = RI, e })(); function RI() { return function lm(e, t) { let n; const r = t[e.index]; if (mt(r)) n = r; else { let o; if (8 & e.type) o = Se(r); else { const i = t[V]; o = i.createComment(""); const s = et(e, t); xn(i, Ni(i, s), o, function b_(e, t) { return e.nextSibling(t) }(i, s), !1) } t[e.index] = n = function np(e, t, n, r) { return [e, !0, !1, t, null, 0, r, n, null, null] }(r, t, o, e), Zi(t, n) } return new am(n, e, t) }(Ie(), v()) } const xI = Ct, am = class extends xI { constructor(t, n, r) { super(), this._lContainer = t, this._hostTNode = n, this._hostLView = r } get element() { return dr(this._hostTNode, this._hostLView) } get injector() { return new tr(this._hostTNode, this._hostLView) } get parentInjector() { const t = za(this._hostTNode, this._hostLView); if (uf(t)) { const n = bi(t, this._hostLView), r = Ei(t); return new tr(n[E].data[r + 8], n) } return new tr(null, this._hostLView) } clear() { for (; this.length > 0;)this.remove(this.length - 1) } get(t) { const n = um(this._lContainer); return null !== n && n[t] || null } get length() { return this._lContainer.length - Le } createEmbeddedView(t, n, r) { let o, i; "number" == typeof r ? o = r : null != r && (o = r.index, i = r.injector); const s = t.createEmbeddedView(n || {}, i); return this.insert(s, o), s } createComponent(t, n, r, o, i) { const s = t && !function oo(e) { return "function" == typeof e }(t); let a; if (s) a = n; else { const d = n || {}; a = d.index, r = d.injector, o = d.projectableNodes, i = d.environmentInjector || d.ngModuleRef } const u = s ? t : new wo(Q(t)), l = r || this.parentInjector; if (!i && null == u.ngModule) { const f = (s ? l : this.parentInjector).get(Yt, null); f && (i = f) } const c = u.create(l, o, void 0, i); return this.insert(c.hostView, a), c } insert(t, n) { const r = t._lView, o = r[E]; if (function Kw(e) { return mt(e[ae]) }(r)) { const c = this.indexOf(t); if (-1 !== c) this.detach(c); else { const d = r[ae], f = new am(d, d[Ae], d[ae]); f.detach(f.indexOf(t)) } } const i = this._adjustIndex(n), s = this._lContainer; !function D_(e, t, n, r) { const o = Le + r, i = n.length; r > 0 && (n[o - 1][gt] = t), r < i - Le ? (t[gt] = n[o], Cf(n, Le + r, t)) : (n.push(t), t[gt] = null), t[ae] = n; const s = t[Kr]; null !== s && n !== s && function w_(e, t) { const n = e[Kn]; t[Re] !== t[ae][ae][Re] && (e[Od] = !0), null === n ? e[Kn] = [t] : n.push(t) }(s, t); const a = t[At]; null !== a && a.insertView(e), t[j] |= 64 }(o, r, s, i); const a = hu(i, s), u = r[V], l = Ni(u, s[gi]); return null !== l && function m_(e, t, n, r, o, i) { r[Gt] = o, r[Ae] = t, ho(e, r, n, 1, o, i) }(o, s[Ae], u, r, l, a), t.attachToViewContainerRef(), Cf(vl(s), i, t), t } move(t, n) { return this.insert(t, n) } indexOf(t) { const n = um(this._lContainer); return null !== n ? n.indexOf(t) : -1 } remove(t) { const n = this._adjustIndex(t, -1), r = cu(this._lContainer, n); r && (Ai(vl(this._lContainer), n), Gf(r[E], r)) } detach(t) { const n = this._adjustIndex(t, -1), r = cu(this._lContainer, n); return r && null != Ai(vl(this._lContainer), n) ? new Do(r) : null } _adjustIndex(t, n = 0) { return t ?? this.length + n } }; function um(e) { return e[mi] } function vl(e) { return e[mi] || (e[mi] = []) } function ps(...e) { } const gs = new x("Application Initializer"); let ms = (() => { class e { constructor(n) { this.appInits = n, this.resolve = ps, this.reject = ps, this.initialized = !1, this.done = !1, this.donePromise = new Promise((r, o) => { this.resolve = r, this.reject = o }) } runInitializers() { if (this.initialized) return; const n = [], r = () => { this.done = !0, this.resolve() }; if (this.appInits) for (let o = 0; o < this.appInits.length; o++) { const i = this.appInits[o](); if (ts(i)) n.push(i); else if (Sp(i)) { const s = new Promise((a, u) => { i.subscribe({ complete: a, error: u }) }); n.push(s) } } Promise.all(n).then(() => { r() }).catch(o => { this.reject(o) }), 0 === n.length && r(), this.initialized = !0 } } return e.\u0275fac = function (n) { return new (n || e)(R(gs, 8)) }, e.\u0275prov = N({ token: e, factory: e.\u0275fac, providedIn: "root" }), e })(); const xo = new x("AppId", { providedIn: "root", factory: function Fm() { return `${Al()}${Al()}${Al()}` } }); function Al() { return String.fromCharCode(97 + Math.floor(25 * Math.random())) } const km = new x("Platform Initializer"), Lm = new x("Platform ID", { providedIn: "platform", factory: () => "unknown" }); let iM = (() => { class e { log(n) { console.log(n) } warn(n) { console.warn(n) } } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275prov = N({ token: e, factory: e.\u0275fac, providedIn: "platform" }), e })(); const en = new x("LocaleId", { providedIn: "root", factory: () => z(en, A.Optional | A.SkipSelf) || function sM() { return typeof $localize < "u" && $localize.locale || Mr }() }); class uM { constructor(t, n) { this.ngModuleFactory = t, this.componentFactories = n } } let jm = (() => { class e { compileModuleSync(n) { return new hl(n) } compileModuleAsync(n) { return Promise.resolve(this.compileModuleSync(n)) } compileModuleAndAllComponentsSync(n) { const r = this.compileModuleSync(n), i = Qt(Xe(n).declarations).reduce((s, a) => { const u = Q(a); return u && s.push(new wo(u)), s }, []); return new uM(r, i) } compileModuleAndAllComponentsAsync(n) { return Promise.resolve(this.compileModuleAndAllComponentsSync(n)) } clearCache() { } clearCacheFor(n) { } getModuleId(n) { } } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275prov = N({ token: e, factory: e.\u0275fac, providedIn: "root" }), e })(); const dM = (() => Promise.resolve(0))(); function Rl(e) { typeof Zone > "u" ? dM.then(() => { e && e.apply(null, null) }) : Zone.current.scheduleMicroTask("scheduleMicrotask", e) } class ce { constructor({ enableLongStackTrace: t = !1, shouldCoalesceEventChangeDetection: n = !1, shouldCoalesceRunChangeDetection: r = !1 }) { if (this.hasPendingMacrotasks = !1, this.hasPendingMicrotasks = !1, this.isStable = !0, this.onUnstable = new Oe(!1), this.onMicrotaskEmpty = new Oe(!1), this.onStable = new Oe(!1), this.onError = new Oe(!1), typeof Zone > "u") throw new w(908, !1); Zone.assertZonePatched(); const o = this; o._nesting = 0, o._outer = o._inner = Zone.current, Zone.TaskTrackingZoneSpec && (o._inner = o._inner.fork(new Zone.TaskTrackingZoneSpec)), t && Zone.longStackTraceZoneSpec && (o._inner = o._inner.fork(Zone.longStackTraceZoneSpec)), o.shouldCoalesceEventChangeDetection = !r && n, o.shouldCoalesceRunChangeDetection = r, o.lastRequestAnimationFrameId = -1, o.nativeRequestAnimationFrame = function fM() { let e = te.requestAnimationFrame, t = te.cancelAnimationFrame; if (typeof Zone < "u" && e && t) { const n = e[Zone.__symbol__("OriginalDelegate")]; n && (e = n); const r = t[Zone.__symbol__("OriginalDelegate")]; r && (t = r) } return { nativeRequestAnimationFrame: e, nativeCancelAnimationFrame: t } }().nativeRequestAnimationFrame, function gM(e) { const t = () => { !function pM(e) { e.isCheckStableRunning || -1 !== e.lastRequestAnimationFrameId || (e.lastRequestAnimationFrameId = e.nativeRequestAnimationFrame.call(te, () => { e.fakeTopEventTask || (e.fakeTopEventTask = Zone.root.scheduleEventTask("fakeTopEventTask", () => { e.lastRequestAnimationFrameId = -1, Pl(e), e.isCheckStableRunning = !0, xl(e), e.isCheckStableRunning = !1 }, void 0, () => { }, () => { })), e.fakeTopEventTask.invoke() }), Pl(e)) }(e) }; e._inner = e._inner.fork({ name: "angular", properties: { isAngularZone: !0 }, onInvokeTask: (n, r, o, i, s, a) => { try { return Um(e), n.invokeTask(o, i, s, a) } finally { (e.shouldCoalesceEventChangeDetection && "eventTask" === i.type || e.shouldCoalesceRunChangeDetection) && t(), Bm(e) } }, onInvoke: (n, r, o, i, s, a, u) => { try { return Um(e), n.invoke(o, i, s, a, u) } finally { e.shouldCoalesceRunChangeDetection && t(), Bm(e) } }, onHasTask: (n, r, o, i) => { n.hasTask(o, i), r === o && ("microTask" == i.change ? (e._hasPendingMicrotasks = i.microTask, Pl(e), xl(e)) : "macroTask" == i.change && (e.hasPendingMacrotasks = i.macroTask)) }, onHandleError: (n, r, o, i) => (n.handleError(o, i), e.runOutsideAngular(() => e.onError.emit(i)), !1) }) }(o) } static isInAngularZone() { return typeof Zone < "u" && !0 === Zone.current.get("isAngularZone") } static assertInAngularZone() { if (!ce.isInAngularZone()) throw new w(909, !1) } static assertNotInAngularZone() { if (ce.isInAngularZone()) throw new w(909, !1) } run(t, n, r) { return this._inner.run(t, n, r) } runTask(t, n, r, o) { const i = this._inner, s = i.scheduleEventTask("NgZoneEvent: " + o, t, hM, ps, ps); try { return i.runTask(s, n, r) } finally { i.cancelTask(s) } } runGuarded(t, n, r) { return this._inner.runGuarded(t, n, r) } runOutsideAngular(t) { return this._outer.run(t) } } const hM = {}; function xl(e) { if (0 == e._nesting && !e.hasPendingMicrotasks && !e.isStable) try { e._nesting++, e.onMicrotaskEmpty.emit(null) } finally { if (e._nesting--, !e.hasPendingMicrotasks) try { e.runOutsideAngular(() => e.onStable.emit(null)) } finally { e.isStable = !0 } } } function Pl(e) { e.hasPendingMicrotasks = !!(e._hasPendingMicrotasks || (e.shouldCoalesceEventChangeDetection || e.shouldCoalesceRunChangeDetection) && -1 !== e.lastRequestAnimationFrameId) } function Um(e) { e._nesting++, e.isStable && (e.isStable = !1, e.onUnstable.emit(null)) } function Bm(e) { e._nesting--, xl(e) } class mM { constructor() { this.hasPendingMicrotasks = !1, this.hasPendingMacrotasks = !1, this.isStable = !0, this.onUnstable = new Oe, this.onMicrotaskEmpty = new Oe, this.onStable = new Oe, this.onError = new Oe } run(t, n, r) { return t.apply(n, r) } runGuarded(t, n, r) { return t.apply(n, r) } runOutsideAngular(t) { return t() } runTask(t, n, r, o) { return t.apply(n, r) } } const Hm = new x(""), ys = new x(""); let Fl, Nl = (() => { class e { constructor(n, r, o) { this._ngZone = n, this.registry = r, this._pendingCount = 0, this._isZoneStable = !0, this._didWork = !1, this._callbacks = [], this.taskTrackingZone = null, Fl || (function yM(e) { Fl = e }(o), o.addToWindow(r)), this._watchAngularEvents(), n.run(() => { this.taskTrackingZone = typeof Zone > "u" ? null : Zone.current.get("TaskTrackingZone") }) } _watchAngularEvents() { this._ngZone.onUnstable.subscribe({ next: () => { this._didWork = !0, this._isZoneStable = !1 } }), this._ngZone.runOutsideAngular(() => { this._ngZone.onStable.subscribe({ next: () => { ce.assertNotInAngularZone(), Rl(() => { this._isZoneStable = !0, this._runCallbacksIfReady() }) } }) }) } increasePendingRequestCount() { return this._pendingCount += 1, this._didWork = !0, this._pendingCount } decreasePendingRequestCount() { if (this._pendingCount -= 1, this._pendingCount < 0) throw new Error("pending async requests below zero"); return this._runCallbacksIfReady(), this._pendingCount } isStable() { return this._isZoneStable && 0 === this._pendingCount && !this._ngZone.hasPendingMacrotasks } _runCallbacksIfReady() { if (this.isStable()) Rl(() => { for (; 0 !== this._callbacks.length;) { let n = this._callbacks.pop(); clearTimeout(n.timeoutId), n.doneCb(this._didWork) } this._didWork = !1 }); else { let n = this.getPendingTasks(); this._callbacks = this._callbacks.filter(r => !r.updateCb || !r.updateCb(n) || (clearTimeout(r.timeoutId), !1)), this._didWork = !0 } } getPendingTasks() { return this.taskTrackingZone ? this.taskTrackingZone.macroTasks.map(n => ({ source: n.source, creationLocation: n.creationLocation, data: n.data })) : [] } addCallback(n, r, o) { let i = -1; r && r > 0 && (i = setTimeout(() => { this._callbacks = this._callbacks.filter(s => s.timeoutId !== i), n(this._didWork, this.getPendingTasks()) }, r)), this._callbacks.push({ doneCb: n, timeoutId: i, updateCb: o }) } whenStable(n, r, o) { if (o && !this.taskTrackingZone) throw new Error('Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/plugins/task-tracking" loaded?'); this.addCallback(n, r, o), this._runCallbacksIfReady() } getPendingRequestCount() { return this._pendingCount } registerApplication(n) { this.registry.registerApplication(n, this) } unregisterApplication(n) { this.registry.unregisterApplication(n) } findProviders(n, r, o) { return [] } } return e.\u0275fac = function (n) { return new (n || e)(R(ce), R(Ol), R(ys)) }, e.\u0275prov = N({ token: e, factory: e.\u0275fac }), e })(), Ol = (() => { class e { constructor() { this._applications = new Map } registerApplication(n, r) { this._applications.set(n, r) } unregisterApplication(n) { this._applications.delete(n) } unregisterAllApplications() { this._applications.clear() } getTestability(n) { return this._applications.get(n) || null } getAllTestabilities() { return Array.from(this._applications.values()) } getAllRootElements() { return Array.from(this._applications.keys()) } findTestabilityInTree(n, r = !0) { return Fl?.findTestabilityInTree(this, n, r) ?? null } } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275prov = N({ token: e, factory: e.\u0275fac, providedIn: "platform" }), e })(); const tn = !1; let hn = null; const zm = new x("AllowMultipleToken"), kl = new x("PlatformDestroyListeners"), Gm = new x("appBootstrapListener"); class Wm { constructor(t, n) { this.name = t, this.token = n } } function Zm(e, t, n = []) { const r = `Platform: ${t}`, o = new x(r); return (i = []) => { let s = Ll(); if (!s || s.injector.get(zm, !1)) { const a = [...n, ...i, { provide: o, useValue: !0 }]; e ? e(a) : function wM(e) { if (hn && !hn.get(zm, !1)) throw new w(400, !1); hn = e; const t = e.get(Qm); (function qm(e) { const t = e.get(km, null); t && t.forEach(n => n()) })(e) }(function Ym(e = [], t) { return Kt.create({ name: t, providers: [{ provide: Iu, useValue: "platform" }, { provide: kl, useValue: new Set([() => hn = null]) }, ...e] }) }(a, r)) } return function _M(e) { const t = Ll(); if (!t) throw new w(401, !1); return t }() } } function Ll() { return hn?.get(Qm) ?? null } let Qm = (() => { class e { constructor(n) { this._injector = n, this._modules = [], this._destroyListeners = [], this._destroyed = !1 } bootstrapModuleFactory(n, r) { const o = function Xm(e, t) { let n; return n = "noop" === e ? new mM : ("zone.js" === e ? void 0 : e) || new ce(t), n }(r?.ngZone, function Km(e) { return { enableLongStackTrace: !1, shouldCoalesceEventChangeDetection: !(!e || !e.ngZoneEventCoalescing) || !1, shouldCoalesceRunChangeDetection: !(!e || !e.ngZoneRunCoalescing) || !1 } }(r)), i = [{ provide: ce, useValue: o }]; return o.run(() => { const s = Kt.create({ providers: i, parent: this.injector, name: n.moduleType.name }), a = n.create(s), u = a.injector.get(fr, null); if (!u) throw new w(402, !1); return o.runOutsideAngular(() => { const l = o.onError.subscribe({ next: c => { u.handleError(c) } }); a.onDestroy(() => { Ds(this._modules, a), l.unsubscribe() }) }), function Jm(e, t, n) { try { const r = n(); return ts(r) ? r.catch(o => { throw t.runOutsideAngular(() => e.handleError(o)), o }) : r } catch (r) { throw t.runOutsideAngular(() => e.handleError(r)), r } }(u, o, () => { const l = a.injector.get(ms); return l.runInitializers(), l.donePromise.then(() => (function _g(e) { st(e, "Expected localeId to be defined"), "string" == typeof e && (Cg = e.toLowerCase().replace(/_/g, "-")) }(a.injector.get(en, Mr) || Mr), this._moduleDoBootstrap(a), a)) }) }) } bootstrapModule(n, r = []) { const o = ey({}, r); return function vM(e, t, n) { const r = new hl(n); return Promise.resolve(r) }(0, 0, n).then(i => this.bootstrapModuleFactory(i, o)) } _moduleDoBootstrap(n) { const r = n.injector.get(vs); if (n._bootstrapComponents.length > 0) n._bootstrapComponents.forEach(o => r.bootstrap(o)); else { if (!n.instance.ngDoBootstrap) throw new w(-403, !1); n.instance.ngDoBootstrap(r) } this._modules.push(n) } onDestroy(n) { this._destroyListeners.push(n) } get injector() { return this._injector } destroy() { if (this._destroyed) throw new w(404, !1); this._modules.slice().forEach(r => r.destroy()), this._destroyListeners.forEach(r => r()); const n = this._injector.get(kl, null); n && (n.forEach(r => r()), n.clear()), this._destroyed = !0 } get destroyed() { return this._destroyed } } return e.\u0275fac = function (n) { return new (n || e)(R(Kt)) }, e.\u0275prov = N({ token: e, factory: e.\u0275fac, providedIn: "platform" }), e })(); function ey(e, t) { return Array.isArray(t) ? t.reduce(ey, e) : { ...e, ...t } } let vs = (() => { class e { get destroyed() { return this._destroyed } get injector() { return this._injector } constructor(n, r, o) { this._zone = n, this._injector = r, this._exceptionHandler = o, this._bootstrapListeners = [], this._views = [], this._runningTick = !1, this._stable = !0, this._destroyed = !1, this._destroyListeners = [], this.componentTypes = [], this.components = [], this._onMicrotaskEmptySubscription = this._zone.onMicrotaskEmpty.subscribe({ next: () => { this._zone.run(() => { this.tick() }) } }); const i = new ye(a => { this._stable = this._zone.isStable && !this._zone.hasPendingMacrotasks && !this._zone.hasPendingMicrotasks, this._zone.runOutsideAngular(() => { a.next(this._stable), a.complete() }) }), s = new ye(a => { let u; this._zone.runOutsideAngular(() => { u = this._zone.onStable.subscribe(() => { ce.assertNotInAngularZone(), Rl(() => { !this._stable && !this._zone.hasPendingMacrotasks && !this._zone.hasPendingMicrotasks && (this._stable = !0, a.next(!0)) }) }) }); const l = this._zone.onUnstable.subscribe(() => { ce.assertInAngularZone(), this._stable && (this._stable = !1, this._zone.runOutsideAngular(() => { a.next(!1) })) }); return () => { u.unsubscribe(), l.unsubscribe() } }); this.isStable = function mw(...e) { const t = zr(e), n = function lw(e, t) { return "number" == typeof pa(e) ? e.pop() : t }(e, 1 / 0), r = e; return r.length ? 1 === r.length ? pt(r[0]) : Gn(n)(ve(r, t)) : It }(i, s.pipe(function yw(e = {}) { const { connector: t = (() => new Vt), resetOnError: n = !0, resetOnComplete: r = !0, resetOnRefCountZero: o = !0 } = e; return i => { let s, a, u, l = 0, c = !1, d = !1; const f = () => { a?.unsubscribe(), a = void 0 }, h = () => { f(), s = u = void 0, c = d = !1 }, p = () => { const g = s; h(), g?.unsubscribe() }; return _e((g, y) => { l++, !d && !c && f(); const D = u = u ?? t(); y.add(() => { l--, 0 === l && !d && !c && (a = ga(p, o)) }), D.subscribe(y), !s && l > 0 && (s = new Hr({ next: _ => D.next(_), error: _ => { d = !0, f(), a = ga(h, n, _), D.error(_) }, complete: () => { c = !0, f(), a = ga(h, r), D.complete() } }), pt(g).subscribe(s)) })(i) } }())) } bootstrap(n, r) { const o = n instanceof Ih; if (!this._injector.get(ms).done) { !o && function qn(e) { const t = Q(e) || Te(e) || ze(e); return null !== t && t.standalone }(n); throw new w(405, tn) } let s; s = o ? n : this._injector.get(yo).resolveComponentFactory(n), this.componentTypes.push(s.componentType); const a = function DM(e) { return e.isBoundToModule }(s) ? void 0 : this._injector.get(Tr), l = s.create(Kt.NULL, [], r || s.selector, a), c = l.location.nativeElement, d = l.injector.get(Hm, null); return d?.registerApplication(c), l.onDestroy(() => { this.detachView(l.hostView), Ds(this.components, l), d?.unregisterApplication(c) }), this._loadComponent(l), l } tick() { if (this._runningTick) throw new w(101, !1); try { this._runningTick = !0; for (let n of this._views) n.detectChanges() } catch (n) { this._zone.runOutsideAngular(() => this._exceptionHandler.handleError(n)) } finally { this._runningTick = !1 } } attachView(n) { const r = n; this._views.push(r), r.attachToAppRef(this) } detachView(n) { const r = n; Ds(this._views, r), r.detachFromAppRef() } _loadComponent(n) { this.attachView(n.hostView), this.tick(), this.components.push(n); const r = this._injector.get(Gm, []); r.push(...this._bootstrapListeners), r.forEach(o => o(n)) } ngOnDestroy() { if (!this._destroyed) try { this._destroyListeners.forEach(n => n()), this._views.slice().forEach(n => n.destroy()), this._onMicrotaskEmptySubscription.unsubscribe() } finally { this._destroyed = !0, this._views = [], this._bootstrapListeners = [], this._destroyListeners = [] } } onDestroy(n) { return this._destroyListeners.push(n), () => Ds(this._destroyListeners, n) } destroy() { if (this._destroyed) throw new w(406, !1); const n = this._injector; n.destroy && !n.destroyed && n.destroy() } get viewCount() { return this._views.length } warnIfDestroyed() { } } return e.\u0275fac = function (n) { return new (n || e)(R(ce), R(Yt), R(fr)) }, e.\u0275prov = N({ token: e, factory: e.\u0275fac, providedIn: "root" }), e })(); function Ds(e, t) { const n = e.indexOf(t); n > -1 && e.splice(n, 1) } let jl = (() => { class e { } return e.__NG_ELEMENT_ID__ = bM, e })(); function bM(e) { return function SM(e, t, n) { if (Jr(e) && !n) { const r = Ge(e.index, t); return new Do(r, r) } return 47 & e.type ? new Do(t[Re], t) : null }(Ie(), v(), 16 == (16 & e)) } class iy { constructor() { } supports(t) { return Ji(t) } create(t) { return new xM(t) } } const RM = (e, t) => t; class xM { constructor(t) { this.length = 0, this._linkedRecords = null, this._unlinkedRecords = null, this._previousItHead = null, this._itHead = null, this._itTail = null, this._additionsHead = null, this._additionsTail = null, this._movesHead = null, this._movesTail = null, this._removalsHead = null, this._removalsTail = null, this._identityChangesHead = null, this._identityChangesTail = null, this._trackByFn = t || RM } forEachItem(t) { let n; for (n = this._itHead; null !== n; n = n._next)t(n) } forEachOperation(t) { let n = this._itHead, r = this._removalsHead, o = 0, i = null; for (; n || r;) { const s = !r || n && n.currentIndex < ay(r, o, i) ? n : r, a = ay(s, o, i), u = s.currentIndex; if (s === r) o--, r = r._nextRemoved; else if (n = n._next, null == s.previousIndex) o++; else { i || (i = []); const l = a - o, c = u - o; if (l != c) { for (let f = 0; f < l; f++) { const h = f < i.length ? i[f] : i[f] = 0, p = h + f; c <= p && p < l && (i[f] = h + 1) } i[s.previousIndex] = c - l } } a !== u && t(s, a, u) } } forEachPreviousItem(t) { let n; for (n = this._previousItHead; null !== n; n = n._nextPrevious)t(n) } forEachAddedItem(t) { let n; for (n = this._additionsHead; null !== n; n = n._nextAdded)t(n) } forEachMovedItem(t) { let n; for (n = this._movesHead; null !== n; n = n._nextMoved)t(n) } forEachRemovedItem(t) { let n; for (n = this._removalsHead; null !== n; n = n._nextRemoved)t(n) } forEachIdentityChange(t) { let n; for (n = this._identityChangesHead; null !== n; n = n._nextIdentityChange)t(n) } diff(t) { if (null == t && (t = []), !Ji(t)) throw new w(900, !1); return this.check(t) ? this : null } onDestroy() { } check(t) { this._reset(); let o, i, s, n = this._itHead, r = !1; if (Array.isArray(t)) { this.length = t.length; for (let a = 0; a < this.length; a++)i = t[a], s = this._trackByFn(a, i), null !== n && Object.is(n.trackById, s) ? (r && (n = this._verifyReinsertion(n, i, s, a)), Object.is(n.item, i) || this._addIdentityChange(n, i)) : (n = this._mismatch(n, i, s, a), r = !0), n = n._next } else o = 0, function X0(e, t) { if (Array.isArray(e)) for (let n = 0; n < e.length; n++)t(e[n]); else { const n = e[Symbol.iterator](); let r; for (; !(r = n.next()).done;)t(r.value) } }(t, a => { s = this._trackByFn(o, a), null !== n && Object.is(n.trackById, s) ? (r && (n = this._verifyReinsertion(n, a, s, o)), Object.is(n.item, a) || this._addIdentityChange(n, a)) : (n = this._mismatch(n, a, s, o), r = !0), n = n._next, o++ }), this.length = o; return this._truncate(n), this.collection = t, this.isDirty } get isDirty() { return null !== this._additionsHead || null !== this._movesHead || null !== this._removalsHead || null !== this._identityChangesHead } _reset() { if (this.isDirty) { let t; for (t = this._previousItHead = this._itHead; null !== t; t = t._next)t._nextPrevious = t._next; for (t = this._additionsHead; null !== t; t = t._nextAdded)t.previousIndex = t.currentIndex; for (this._additionsHead = this._additionsTail = null, t = this._movesHead; null !== t; t = t._nextMoved)t.previousIndex = t.currentIndex; this._movesHead = this._movesTail = null, this._removalsHead = this._removalsTail = null, this._identityChangesHead = this._identityChangesTail = null } } _mismatch(t, n, r, o) { let i; return null === t ? i = this._itTail : (i = t._prev, this._remove(t)), null !== (t = null === this._unlinkedRecords ? null : this._unlinkedRecords.get(r, null)) ? (Object.is(t.item, n) || this._addIdentityChange(t, n), this._reinsertAfter(t, i, o)) : null !== (t = null === this._linkedRecords ? null : this._linkedRecords.get(r, o)) ? (Object.is(t.item, n) || this._addIdentityChange(t, n), this._moveAfter(t, i, o)) : t = this._addAfter(new PM(n, r), i, o), t } _verifyReinsertion(t, n, r, o) { let i = null === this._unlinkedRecords ? null : this._unlinkedRecords.get(r, null); return null !== i ? t = this._reinsertAfter(i, t._prev, o) : t.currentIndex != o && (t.currentIndex = o, this._addToMoves(t, o)), t } _truncate(t) { for (; null !== t;) { const n = t._next; this._addToRemovals(this._unlink(t)), t = n } null !== this._unlinkedRecords && this._unlinkedRecords.clear(), null !== this._additionsTail && (this._additionsTail._nextAdded = null), null !== this._movesTail && (this._movesTail._nextMoved = null), null !== this._itTail && (this._itTail._next = null), null !== this._removalsTail && (this._removalsTail._nextRemoved = null), null !== this._identityChangesTail && (this._identityChangesTail._nextIdentityChange = null) } _reinsertAfter(t, n, r) { null !== this._unlinkedRecords && this._unlinkedRecords.remove(t); const o = t._prevRemoved, i = t._nextRemoved; return null === o ? this._removalsHead = i : o._nextRemoved = i, null === i ? this._removalsTail = o : i._prevRemoved = o, this._insertAfter(t, n, r), this._addToMoves(t, r), t } _moveAfter(t, n, r) { return this._unlink(t), this._insertAfter(t, n, r), this._addToMoves(t, r), t } _addAfter(t, n, r) { return this._insertAfter(t, n, r), this._additionsTail = null === this._additionsTail ? this._additionsHead = t : this._additionsTail._nextAdded = t, t } _insertAfter(t, n, r) { const o = null === n ? this._itHead : n._next; return t._next = o, t._prev = n, null === o ? this._itTail = t : o._prev = t, null === n ? this._itHead = t : n._next = t, null === this._linkedRecords && (this._linkedRecords = new sy), this._linkedRecords.put(t), t.currentIndex = r, t } _remove(t) { return this._addToRemovals(this._unlink(t)) } _unlink(t) { null !== this._linkedRecords && this._linkedRecords.remove(t); const n = t._prev, r = t._next; return null === n ? this._itHead = r : n._next = r, null === r ? this._itTail = n : r._prev = n, t } _addToMoves(t, n) { return t.previousIndex === n || (this._movesTail = null === this._movesTail ? this._movesHead = t : this._movesTail._nextMoved = t), t } _addToRemovals(t) { return null === this._unlinkedRecords && (this._unlinkedRecords = new sy), this._unlinkedRecords.put(t), t.currentIndex = null, t._nextRemoved = null, null === this._removalsTail ? (this._removalsTail = this._removalsHead = t, t._prevRemoved = null) : (t._prevRemoved = this._removalsTail, this._removalsTail = this._removalsTail._nextRemoved = t), t } _addIdentityChange(t, n) { return t.item = n, this._identityChangesTail = null === this._identityChangesTail ? this._identityChangesHead = t : this._identityChangesTail._nextIdentityChange = t, t } } class PM { constructor(t, n) { this.item = t, this.trackById = n, this.currentIndex = null, this.previousIndex = null, this._nextPrevious = null, this._prev = null, this._next = null, this._prevDup = null, this._nextDup = null, this._prevRemoved = null, this._nextRemoved = null, this._nextAdded = null, this._nextMoved = null, this._nextIdentityChange = null } } class NM { constructor() { this._head = null, this._tail = null } add(t) { null === this._head ? (this._head = this._tail = t, t._nextDup = null, t._prevDup = null) : (this._tail._nextDup = t, t._prevDup = this._tail, t._nextDup = null, this._tail = t) } get(t, n) { let r; for (r = this._head; null !== r; r = r._nextDup)if ((null === n || n <= r.currentIndex) && Object.is(r.trackById, t)) return r; return null } remove(t) { const n = t._prevDup, r = t._nextDup; return null === n ? this._head = r : n._nextDup = r, null === r ? this._tail = n : r._prevDup = n, null === this._head } } class sy { constructor() { this.map = new Map } put(t) { const n = t.trackById; let r = this.map.get(n); r || (r = new NM, this.map.set(n, r)), r.add(t) } get(t, n) { const o = this.map.get(t); return o ? o.get(t, n) : null } remove(t) { const n = t.trackById; return this.map.get(n).remove(t) && this.map.delete(n), t } get isEmpty() { return 0 === this.map.size } clear() { this.map.clear() } } function ay(e, t, n) { const r = e.previousIndex; if (null === r) return r; let o = 0; return n && r < n.length && (o = n[r]), r + t + o } class uy { constructor() { } supports(t) { return t instanceof Map || Qu(t) } create() { return new OM } } class OM { constructor() { this._records = new Map, this._mapHead = null, this._appendAfter = null, this._previousMapHead = null, this._changesHead = null, this._changesTail = null, this._additionsHead = null, this._additionsTail = null, this._removalsHead = null, this._removalsTail = null } get isDirty() { return null !== this._additionsHead || null !== this._changesHead || null !== this._removalsHead } forEachItem(t) { let n; for (n = this._mapHead; null !== n; n = n._next)t(n) } forEachPreviousItem(t) { let n; for (n = this._previousMapHead; null !== n; n = n._nextPrevious)t(n) } forEachChangedItem(t) { let n; for (n = this._changesHead; null !== n; n = n._nextChanged)t(n) } forEachAddedItem(t) { let n; for (n = this._additionsHead; null !== n; n = n._nextAdded)t(n) } forEachRemovedItem(t) { let n; for (n = this._removalsHead; null !== n; n = n._nextRemoved)t(n) } diff(t) { if (t) { if (!(t instanceof Map || Qu(t))) throw new w(900, !1) } else t = new Map; return this.check(t) ? this : null } onDestroy() { } check(t) { this._reset(); let n = this._mapHead; if (this._appendAfter = null, this._forEach(t, (r, o) => { if (n && n.key === o) this._maybeAddToChanges(n, r), this._appendAfter = n, n = n._next; else { const i = this._getOrCreateRecordForKey(o, r); n = this._insertBeforeOrAppend(n, i) } }), n) { n._prev && (n._prev._next = null), this._removalsHead = n; for (let r = n; null !== r; r = r._nextRemoved)r === this._mapHead && (this._mapHead = null), this._records.delete(r.key), r._nextRemoved = r._next, r.previousValue = r.currentValue, r.currentValue = null, r._prev = null, r._next = null } return this._changesTail && (this._changesTail._nextChanged = null), this._additionsTail && (this._additionsTail._nextAdded = null), this.isDirty } _insertBeforeOrAppend(t, n) { if (t) { const r = t._prev; return n._next = t, n._prev = r, t._prev = n, r && (r._next = n), t === this._mapHead && (this._mapHead = n), this._appendAfter = t, t } return this._appendAfter ? (this._appendAfter._next = n, n._prev = this._appendAfter) : this._mapHead = n, this._appendAfter = n, null } _getOrCreateRecordForKey(t, n) { if (this._records.has(t)) { const o = this._records.get(t); this._maybeAddToChanges(o, n); const i = o._prev, s = o._next; return i && (i._next = s), s && (s._prev = i), o._next = null, o._prev = null, o } const r = new FM(t); return this._records.set(t, r), r.currentValue = n, this._addToAdditions(r), r } _reset() { if (this.isDirty) { let t; for (this._previousMapHead = this._mapHead, t = this._previousMapHead; null !== t; t = t._next)t._nextPrevious = t._next; for (t = this._changesHead; null !== t; t = t._nextChanged)t.previousValue = t.currentValue; for (t = this._additionsHead; null != t; t = t._nextAdded)t.previousValue = t.currentValue; this._changesHead = this._changesTail = null, this._additionsHead = this._additionsTail = null, this._removalsHead = null } } _maybeAddToChanges(t, n) { Object.is(n, t.currentValue) || (t.previousValue = t.currentValue, t.currentValue = n, this._addToChanges(t)) } _addToAdditions(t) { null === this._additionsHead ? this._additionsHead = this._additionsTail = t : (this._additionsTail._nextAdded = t, this._additionsTail = t) } _addToChanges(t) { null === this._changesHead ? this._changesHead = this._changesTail = t : (this._changesTail._nextChanged = t, this._changesTail = t) } _forEach(t, n) { t instanceof Map ? t.forEach(n) : Object.keys(t).forEach(r => n(t[r], r)) } } class FM { constructor(t) { this.key = t, this.previousValue = null, this.currentValue = null, this._nextPrevious = null, this._next = null, this._prev = null, this._nextAdded = null, this._nextRemoved = null, this._nextChanged = null } } function ly() { return new _s([new iy]) } let _s = (() => { class e { constructor(n) { this.factories = n } static create(n, r) { if (null != r) { const o = r.factories.slice(); n = n.concat(o) } return new e(n) } static extend(n) { return { provide: e, useFactory: r => e.create(n, r || ly()), deps: [[e, new ao, new so]] } } find(n) { const r = this.factories.find(o => o.supports(n)); if (null != r) return r; throw new w(901, !1) } } return e.\u0275prov = N({ token: e, providedIn: "root", factory: ly }), e })(); function cy() { return new Po([new uy]) } let Po = (() => { class e { constructor(n) { this.factories = n } static create(n, r) { if (r) { const o = r.factories.slice(); n = n.concat(o) } return new e(n) } static extend(n) { return { provide: e, useFactory: r => e.create(n, r || cy()), deps: [[e, new ao, new so]] } } find(n) { const r = this.factories.find(o => o.supports(n)); if (r) return r; throw new w(901, !1) } } return e.\u0275prov = N({ token: e, providedIn: "root", factory: cy }), e })(); const jM = Zm(null, "core", []); let $M = (() => { class e { constructor(n) { } } return e.\u0275fac = function (n) { return new (n || e)(R(vs)) }, e.\u0275mod = bn({ type: e }), e.\u0275inj = un({}), e })(); function Hl(e) { return "boolean" == typeof e ? e : null != e && "false" !== e } let zl = null; function jn() { return zl } class BM { } const Ze = new x("DocumentToken"); let Gl = (() => { class e { historyGo(n) { throw new Error("Not implemented") } } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275prov = N({ token: e, factory: function () { return function HM() { return R(dy) }() }, providedIn: "platform" }), e })(); const zM = new x("Location Initialized"); let dy = (() => { class e extends Gl { constructor(n) { super(), this._doc = n, this._location = window.location, this._history = window.history } getBaseHrefFromDOM() { return jn().getBaseHref(this._doc) } onPopState(n) { const r = jn().getGlobalEventTarget(this._doc, "window"); return r.addEventListener("popstate", n, !1), () => r.removeEventListener("popstate", n) } onHashChange(n) { const r = jn().getGlobalEventTarget(this._doc, "window"); return r.addEventListener("hashchange", n, !1), () => r.removeEventListener("hashchange", n) } get href() { return this._location.href } get protocol() { return this._location.protocol } get hostname() { return this._location.hostname } get port() { return this._location.port } get pathname() { return this._location.pathname } get search() { return this._location.search } get hash() { return this._location.hash } set pathname(n) { this._location.pathname = n } pushState(n, r, o) { fy() ? this._history.pushState(n, r, o) : this._location.hash = o } replaceState(n, r, o) { fy() ? this._history.replaceState(n, r, o) : this._location.hash = o } forward() { this._history.forward() } back() { this._history.back() } historyGo(n = 0) { this._history.go(n) } getState() { return this._history.state } } return e.\u0275fac = function (n) { return new (n || e)(R(Ze)) }, e.\u0275prov = N({ token: e, factory: function () { return function GM() { return new dy(R(Ze)) }() }, providedIn: "platform" }), e })(); function fy() { return !!window.history.pushState } function Wl(e, t) { if (0 == e.length) return t; if (0 == t.length) return e; let n = 0; return e.endsWith("/") && n++, t.startsWith("/") && n++, 2 == n ? e + t.substring(1) : 1 == n ? e + t : e + "/" + t } function hy(e) { const t = e.match(/#|\?|$/), n = t && t.index || e.length; return e.slice(0, n - ("/" === e[n - 1] ? 1 : 0)) + e.slice(n) } function nn(e) { return e && "?" !== e[0] ? "?" + e : e } let $n = (() => { class e { historyGo(n) { throw new Error("Not implemented") } } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275prov = N({ token: e, factory: function () { return z(gy) }, providedIn: "root" }), e })(); const py = new x("appBaseHref"); let gy = (() => { class e extends $n { constructor(n, r) { super(), this._platformLocation = n, this._removeListenerFns = [], this._baseHref = r ?? this._platformLocation.getBaseHrefFromDOM() ?? z(Ze).location?.origin ?? "" } ngOnDestroy() { for (; this._removeListenerFns.length;)this._removeListenerFns.pop()() } onPopState(n) { this._removeListenerFns.push(this._platformLocation.onPopState(n), this._platformLocation.onHashChange(n)) } getBaseHref() { return this._baseHref } prepareExternalUrl(n) { return Wl(this._baseHref, n) } path(n = !1) { const r = this._platformLocation.pathname + nn(this._platformLocation.search), o = this._platformLocation.hash; return o && n ? `${r}${o}` : r } pushState(n, r, o, i) { const s = this.prepareExternalUrl(o + nn(i)); this._platformLocation.pushState(n, r, s) } replaceState(n, r, o, i) { const s = this.prepareExternalUrl(o + nn(i)); this._platformLocation.replaceState(n, r, s) } forward() { this._platformLocation.forward() } back() { this._platformLocation.back() } getState() { return this._platformLocation.getState() } historyGo(n = 0) { this._platformLocation.historyGo?.(n) } } return e.\u0275fac = function (n) { return new (n || e)(R(Gl), R(py, 8)) }, e.\u0275prov = N({ token: e, factory: e.\u0275fac, providedIn: "root" }), e })(), WM = (() => { class e extends $n { constructor(n, r) { super(), this._platformLocation = n, this._baseHref = "", this._removeListenerFns = [], null != r && (this._baseHref = r) } ngOnDestroy() { for (; this._removeListenerFns.length;)this._removeListenerFns.pop()() } onPopState(n) { this._removeListenerFns.push(this._platformLocation.onPopState(n), this._platformLocation.onHashChange(n)) } getBaseHref() { return this._baseHref } path(n = !1) { let r = this._platformLocation.hash; return null == r && (r = "#"), r.length > 0 ? r.substring(1) : r } prepareExternalUrl(n) { const r = Wl(this._baseHref, n); return r.length > 0 ? "#" + r : r } pushState(n, r, o, i) { let s = this.prepareExternalUrl(o + nn(i)); 0 == s.length && (s = this._platformLocation.pathname), this._platformLocation.pushState(n, r, s) } replaceState(n, r, o, i) { let s = this.prepareExternalUrl(o + nn(i)); 0 == s.length && (s = this._platformLocation.pathname), this._platformLocation.replaceState(n, r, s) } forward() { this._platformLocation.forward() } back() { this._platformLocation.back() } getState() { return this._platformLocation.getState() } historyGo(n = 0) { this._platformLocation.historyGo?.(n) } } return e.\u0275fac = function (n) { return new (n || e)(R(Gl), R(py, 8)) }, e.\u0275prov = N({ token: e, factory: e.\u0275fac }), e })(), ql = (() => { class e { constructor(n) { this._subject = new Oe, this._urlChangeListeners = [], this._urlChangeSubscription = null, this._locationStrategy = n; const r = this._locationStrategy.getBaseHref(); this._basePath = function YM(e) { if (new RegExp("^(https?:)?//").test(e)) { const [, n] = e.split(/\/\/[^\/]+/); return n } return e }(hy(my(r))), this._locationStrategy.onPopState(o => { this._subject.emit({ url: this.path(!0), pop: !0, state: o.state, type: o.type }) }) } ngOnDestroy() { this._urlChangeSubscription?.unsubscribe(), this._urlChangeListeners = [] } path(n = !1) { return this.normalize(this._locationStrategy.path(n)) } getState() { return this._locationStrategy.getState() } isCurrentPathEqualTo(n, r = "") { return this.path() == this.normalize(n + nn(r)) } normalize(n) { return e.stripTrailingSlash(function ZM(e, t) { if (!e || !t.startsWith(e)) return t; const n = t.substring(e.length); return "" === n || ["/", ";", "?", "#"].includes(n[0]) ? n : t }(this._basePath, my(n))) } prepareExternalUrl(n) { return n && "/" !== n[0] && (n = "/" + n), this._locationStrategy.prepareExternalUrl(n) } go(n, r = "", o = null) { this._locationStrategy.pushState(o, "", n, r), this._notifyUrlChangeListeners(this.prepareExternalUrl(n + nn(r)), o) } replaceState(n, r = "", o = null) { this._locationStrategy.replaceState(o, "", n, r), this._notifyUrlChangeListeners(this.prepareExternalUrl(n + nn(r)), o) } forward() { this._locationStrategy.forward() } back() { this._locationStrategy.back() } historyGo(n = 0) { this._locationStrategy.historyGo?.(n) } onUrlChange(n) { return this._urlChangeListeners.push(n), this._urlChangeSubscription || (this._urlChangeSubscription = this.subscribe(r => { this._notifyUrlChangeListeners(r.url, r.state) })), () => { const r = this._urlChangeListeners.indexOf(n); this._urlChangeListeners.splice(r, 1), 0 === this._urlChangeListeners.length && (this._urlChangeSubscription?.unsubscribe(), this._urlChangeSubscription = null) } } _notifyUrlChangeListeners(n = "", r) { this._urlChangeListeners.forEach(o => o(n, r)) } subscribe(n, r, o) { return this._subject.subscribe({ next: n, error: r, complete: o }) } } return e.normalizeQueryParams = nn, e.joinWithSlash = Wl, e.stripTrailingSlash = hy, e.\u0275fac = function (n) { return new (n || e)(R($n)) }, e.\u0275prov = N({ token: e, factory: function () { return function qM() { return new ql(R($n)) }() }, providedIn: "root" }), e })(); function my(e) { return e.replace(/\/index.html$/, "") } const rc = /\s+/, Sy = []; let Iy = (() => { class e { constructor(n, r, o, i) { this._iterableDiffers = n, this._keyValueDiffers = r, this._ngEl = o, this._renderer = i, this.initialClasses = Sy, this.stateMap = new Map } set klass(n) { this.initialClasses = null != n ? n.trim().split(rc) : Sy } set ngClass(n) { this.rawClass = "string" == typeof n ? n.trim().split(rc) : n } ngDoCheck() { for (const r of this.initialClasses) this._updateState(r, !0); const n = this.rawClass; if (Array.isArray(n) || n instanceof Set) for (const r of n) this._updateState(r, !0); else if (null != n) for (const r of Object.keys(n)) this._updateState(r, Boolean(n[r])); this._applyStateDiff() } _updateState(n, r) { const o = this.stateMap.get(n); void 0 !== o ? (o.enabled !== r && (o.changed = !0, o.enabled = r), o.touched = !0) : this.stateMap.set(n, { enabled: r, changed: !0, touched: !0 }) } _applyStateDiff() { for (const n of this.stateMap) { const r = n[0], o = n[1]; o.changed ? (this._toggleClass(r, o.enabled), o.changed = !1) : o.touched || (o.enabled && this._toggleClass(r, !1), this.stateMap.delete(r)), o.touched = !1 } } _toggleClass(n, r) { (n = n.trim()).length > 0 && n.split(rc).forEach(o => { r ? this._renderer.addClass(this._ngEl.nativeElement, o) : this._renderer.removeClass(this._ngEl.nativeElement, o) }) } } return e.\u0275fac = function (n) { return new (n || e)(S(_s), S(Po), S(dn), S(Hi)) }, e.\u0275dir = ke({ type: e, selectors: [["", "ngClass", ""]], inputs: { klass: ["class", "klass"], ngClass: "ngClass" }, standalone: !0 }), e })(), lA = (() => { class e { } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275mod = bn({ type: e }), e.\u0275inj = un({}), e })(); let hA = (() => { class e { } return e.\u0275prov = N({ token: e, providedIn: "root", factory: () => new pA(R(Ze), window) }), e })(); class pA { constructor(t, n) { this.document = t, this.window = n, this.offset = () => [0, 0] } setOffset(t) { this.offset = Array.isArray(t) ? () => t : t } getScrollPosition() { return this.supportsScrolling() ? [this.window.pageXOffset, this.window.pageYOffset] : [0, 0] } scrollToPosition(t) { this.supportsScrolling() && this.window.scrollTo(t[0], t[1]) } scrollToAnchor(t) { if (!this.supportsScrolling()) return; const n = function gA(e, t) { const n = e.getElementById(t) || e.getElementsByName(t)[0]; if (n) return n; if ("function" == typeof e.createTreeWalker && e.body && (e.body.createShadowRoot || e.body.attachShadow)) { const r = e.createTreeWalker(e.body, NodeFilter.SHOW_ELEMENT); let o = r.currentNode; for (; o;) { const i = o.shadowRoot; if (i) { const s = i.getElementById(t) || i.querySelector(`[name="${t}"]`); if (s) return s } o = r.nextNode() } } return null }(this.document, t); n && (this.scrollToElement(n), n.focus()) } setHistoryScrollRestoration(t) { if (this.supportScrollRestoration()) { const n = this.window.history; n && n.scrollRestoration && (n.scrollRestoration = t) } } scrollToElement(t) { const n = t.getBoundingClientRect(), r = n.left + this.window.pageXOffset, o = n.top + this.window.pageYOffset, i = this.offset(); this.window.scrollTo(r - i[0], o - i[1]) } supportScrollRestoration() { try { if (!this.supportsScrolling()) return !1; const t = Oy(this.window.history) || Oy(Object.getPrototypeOf(this.window.history)); return !(!t || !t.writable && !t.set) } catch { return !1 } } supportsScrolling() { try { return !!this.window && !!this.window.scrollTo && "pageXOffset" in this.window } catch { return !1 } } } function Oy(e) { return Object.getOwnPropertyDescriptor(e, "scrollRestoration") } class HA extends BM { constructor() { super(...arguments), this.supportsDOMEvents = !0 } } class cc extends HA { static makeCurrent() { !function UM(e) { zl || (zl = e) }(new cc) } onAndCancel(t, n, r) { return t.addEventListener(n, r, !1), () => { t.removeEventListener(n, r, !1) } } dispatchEvent(t, n) { t.dispatchEvent(n) } remove(t) { t.parentNode && t.parentNode.removeChild(t) } createElement(t, n) { return (n = n || this.getDefaultDocument()).createElement(t) } createHtmlDocument() { return document.implementation.createHTMLDocument("fakeTitle") } getDefaultDocument() { return document } isElementNode(t) { return t.nodeType === Node.ELEMENT_NODE } isShadowRoot(t) { return t instanceof DocumentFragment } getGlobalEventTarget(t, n) { return "window" === n ? window : "document" === n ? t : "body" === n ? t.body : null } getBaseHref(t) { const n = function zA() { return ko = ko || document.querySelector("base"), ko ? ko.getAttribute("href") : null }(); return null == n ? null : function GA(e) { Os = Os || document.createElement("a"), Os.setAttribute("href", e); const t = Os.pathname; return "/" === t.charAt(0) ? t : `/${t}` }(n) } resetBaseElement() { ko = null } getUserAgent() { return window.navigator.userAgent } getCookie(t) { return function PT(e, t) { t = encodeURIComponent(t); for (const n of e.split(";")) { const r = n.indexOf("="), [o, i] = -1 == r ? [n, ""] : [n.slice(0, r), n.slice(r + 1)]; if (o.trim() === t) return decodeURIComponent(i) } return null }(document.cookie, t) } } let Os, ko = null; const $y = new x("TRANSITION_ID"), qA = [{ provide: gs, useFactory: function WA(e, t, n) { return () => { n.get(ms).donePromise.then(() => { const r = jn(), o = t.querySelectorAll(`style[ng-transition="${e}"]`); for (let i = 0; i < o.length; i++)r.remove(o[i]) }) } }, deps: [$y, Ze, Kt], multi: !0 }]; let YA = (() => { class e { build() { return new XMLHttpRequest } } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275prov = N({ token: e, factory: e.\u0275fac }), e })(); const Fs = new x("EventManagerPlugins"); let ks = (() => { class e { constructor(n, r) { this._zone = r, this._eventNameToPlugin = new Map, n.forEach(o => { o.manager = this }), this._plugins = n.slice().reverse() } addEventListener(n, r, o) { return this._findPluginFor(r).addEventListener(n, r, o) } addGlobalEventListener(n, r, o) { return this._findPluginFor(r).addGlobalEventListener(n, r, o) } getZone() { return this._zone } _findPluginFor(n) { const r = this._eventNameToPlugin.get(n); if (r) return r; const o = this._plugins; for (let i = 0; i < o.length; i++) { const s = o[i]; if (s.supports(n)) return this._eventNameToPlugin.set(n, s), s } throw new Error(`No event manager plugin found for event ${n}`) } } return e.\u0275fac = function (n) { return new (n || e)(R(Fs), R(ce)) }, e.\u0275prov = N({ token: e, factory: e.\u0275fac }), e })(); class Vy { constructor(t) { this._doc = t } addGlobalEventListener(t, n, r) { const o = jn().getGlobalEventTarget(this._doc, t); if (!o) throw new Error(`Unsupported event target ${o} for event ${n}`); return this.addEventListener(o, n, r) } } let Uy = (() => { class e { constructor() { this.usageCount = new Map } addStyles(n) { for (const r of n) 1 === this.changeUsageCount(r, 1) && this.onStyleAdded(r) } removeStyles(n) { for (const r of n) 0 === this.changeUsageCount(r, -1) && this.onStyleRemoved(r) } onStyleRemoved(n) { } onStyleAdded(n) { } getAllStyles() { return this.usageCount.keys() } changeUsageCount(n, r) { const o = this.usageCount; let i = o.get(n) ?? 0; return i += r, i > 0 ? o.set(n, i) : o.delete(n), i } ngOnDestroy() { for (const n of this.getAllStyles()) this.onStyleRemoved(n); this.usageCount.clear() } } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275prov = N({ token: e, factory: e.\u0275fac }), e })(), Lo = (() => { class e extends Uy { constructor(n) { super(), this.doc = n, this.styleRef = new Map, this.hostNodes = new Set, this.resetHostNodes() } onStyleAdded(n) { for (const r of this.hostNodes) this.addStyleToHost(r, n) } onStyleRemoved(n) { const r = this.styleRef; r.get(n)?.forEach(i => i.remove()), r.delete(n) } ngOnDestroy() { super.ngOnDestroy(), this.styleRef.clear(), this.resetHostNodes() } addHost(n) { this.hostNodes.add(n); for (const r of this.getAllStyles()) this.addStyleToHost(n, r) } removeHost(n) { this.hostNodes.delete(n) } addStyleToHost(n, r) { const o = this.doc.createElement("style"); o.textContent = r, n.appendChild(o); const i = this.styleRef.get(r); i ? i.push(o) : this.styleRef.set(r, [o]) } resetHostNodes() { const n = this.hostNodes; n.clear(), n.add(this.doc.head) } } return e.\u0275fac = function (n) { return new (n || e)(R(Ze)) }, e.\u0275prov = N({ token: e, factory: e.\u0275fac }), e })(); const dc = { svg: "http://www.w3.org/2000/svg", xhtml: "http://www.w3.org/1999/xhtml", xlink: "http://www.w3.org/1999/xlink", xml: "http://www.w3.org/XML/1998/namespace", xmlns: "http://www.w3.org/2000/xmlns/", math: "http://www.w3.org/1998/MathML/" }, fc = /%COMP%/g, zy = new x("RemoveStylesOnCompDestory", { providedIn: "root", factory: () => !1 }); function Gy(e, t) { return t.flat(100).map(n => n.replace(fc, e)) } function Wy(e) { return t => { if ("__ngUnwrap__" === t) return e; !1 === e(t) && (t.preventDefault(), t.returnValue = !1) } } let hc = (() => { class e { constructor(n, r, o, i) { this.eventManager = n, this.sharedStylesHost = r, this.appId = o, this.removeStylesOnCompDestory = i, this.rendererByCompId = new Map, this.defaultRenderer = new pc(n) } createRenderer(n, r) { if (!n || !r) return this.defaultRenderer; const o = this.getOrCreateRenderer(n, r); return o instanceof Yy ? o.applyToHost(n) : o instanceof gc && o.applyStyles(), o } getOrCreateRenderer(n, r) { const o = this.rendererByCompId; let i = o.get(r.id); if (!i) { const s = this.eventManager, a = this.sharedStylesHost, u = this.removeStylesOnCompDestory; switch (r.encapsulation) { case Tt.Emulated: i = new Yy(s, a, r, this.appId, u); break; case Tt.ShadowDom: return new nR(s, a, n, r); default: i = new gc(s, a, r, u) }i.onDestroy = () => o.delete(r.id), o.set(r.id, i) } return i } ngOnDestroy() { this.rendererByCompId.clear() } begin() { } end() { } } return e.\u0275fac = function (n) { return new (n || e)(R(ks), R(Lo), R(xo), R(zy)) }, e.\u0275prov = N({ token: e, factory: e.\u0275fac }), e })(); class pc { constructor(t) { this.eventManager = t, this.data = Object.create(null), this.destroyNode = null } destroy() { } createElement(t, n) { return n ? document.createElementNS(dc[n] || n, t) : document.createElement(t) } createComment(t) { return document.createComment(t) } createText(t) { return document.createTextNode(t) } appendChild(t, n) { (Zy(t) ? t.content : t).appendChild(n) } insertBefore(t, n, r) { t && (Zy(t) ? t.content : t).insertBefore(n, r) } removeChild(t, n) { t && t.removeChild(n) } selectRootElement(t, n) { let r = "string" == typeof t ? document.querySelector(t) : t; if (!r) throw new Error(`The selector "${t}" did not match any elements`); return n || (r.textContent = ""), r } parentNode(t) { return t.parentNode } nextSibling(t) { return t.nextSibling } setAttribute(t, n, r, o) { if (o) { n = o + ":" + n; const i = dc[o]; i ? t.setAttributeNS(i, n, r) : t.setAttribute(n, r) } else t.setAttribute(n, r) } removeAttribute(t, n, r) { if (r) { const o = dc[r]; o ? t.removeAttributeNS(o, n) : t.removeAttribute(`${r}:${n}`) } else t.removeAttribute(n) } addClass(t, n) { t.classList.add(n) } removeClass(t, n) { t.classList.remove(n) } setStyle(t, n, r, o) { o & (We.DashCase | We.Important) ? t.style.setProperty(n, r, o & We.Important ? "important" : "") : t.style[n] = r } removeStyle(t, n, r) { r & We.DashCase ? t.style.removeProperty(n) : t.style[n] = "" } setProperty(t, n, r) { t[n] = r } setValue(t, n) { t.nodeValue = n } listen(t, n, r) { return "string" == typeof t ? this.eventManager.addGlobalEventListener(t, n, Wy(r)) : this.eventManager.addEventListener(t, n, Wy(r)) } } function Zy(e) { return "TEMPLATE" === e.tagName && void 0 !== e.content } class nR extends pc { constructor(t, n, r, o) { super(t), this.sharedStylesHost = n, this.hostEl = r, this.shadowRoot = r.attachShadow({ mode: "open" }), this.sharedStylesHost.addHost(this.shadowRoot); const i = Gy(o.id, o.styles); for (const s of i) { const a = document.createElement("style"); a.textContent = s, this.shadowRoot.appendChild(a) } } nodeOrShadowRoot(t) { return t === this.hostEl ? this.shadowRoot : t } appendChild(t, n) { return super.appendChild(this.nodeOrShadowRoot(t), n) } insertBefore(t, n, r) { return super.insertBefore(this.nodeOrShadowRoot(t), n, r) } removeChild(t, n) { return super.removeChild(this.nodeOrShadowRoot(t), n) } parentNode(t) { return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(t))) } destroy() { this.sharedStylesHost.removeHost(this.shadowRoot) } } class gc extends pc { constructor(t, n, r, o, i = r.id) { super(t), this.sharedStylesHost = n, this.removeStylesOnCompDestory = o, this.rendererUsageCount = 0, this.styles = Gy(i, r.styles) } applyStyles() { this.sharedStylesHost.addStyles(this.styles), this.rendererUsageCount++ } destroy() { this.removeStylesOnCompDestory && (this.sharedStylesHost.removeStyles(this.styles), this.rendererUsageCount--, 0 === this.rendererUsageCount && this.onDestroy?.()) } } class Yy extends gc { constructor(t, n, r, o, i) { const s = o + "-" + r.id; super(t, n, r, i, s), this.contentAttr = function JA(e) { return "_ngcontent-%COMP%".replace(fc, e) }(s), this.hostAttr = function eR(e) { return "_nghost-%COMP%".replace(fc, e) }(s) } applyToHost(t) { this.applyStyles(), this.setAttribute(t, this.hostAttr, "") } createElement(t, n) { const r = super.createElement(t, n); return super.setAttribute(r, this.contentAttr, ""), r } } let rR = (() => { class e extends Vy { constructor(n) { super(n) } supports(n) { return !0 } addEventListener(n, r, o) { return n.addEventListener(r, o, !1), () => this.removeEventListener(n, r, o) } removeEventListener(n, r, o) { return n.removeEventListener(r, o) } } return e.\u0275fac = function (n) { return new (n || e)(R(Ze)) }, e.\u0275prov = N({ token: e, factory: e.\u0275fac }), e })(); const Qy = ["alt", "control", "meta", "shift"], oR = { "\b": "Backspace", "\t": "Tab", "\x7f": "Delete", "\x1b": "Escape", Del: "Delete", Esc: "Escape", Left: "ArrowLeft", Right: "ArrowRight", Up: "ArrowUp", Down: "ArrowDown", Menu: "ContextMenu", Scroll: "ScrollLock", Win: "OS" }, iR = { alt: e => e.altKey, control: e => e.ctrlKey, meta: e => e.metaKey, shift: e => e.shiftKey }; let sR = (() => { class e extends Vy { constructor(n) { super(n) } supports(n) { return null != e.parseEventName(n) } addEventListener(n, r, o) { const i = e.parseEventName(r), s = e.eventCallback(i.fullKey, o, this.manager.getZone()); return this.manager.getZone().runOutsideAngular(() => jn().onAndCancel(n, i.domEventName, s)) } static parseEventName(n) { const r = n.toLowerCase().split("."), o = r.shift(); if (0 === r.length || "keydown" !== o && "keyup" !== o) return null; const i = e._normalizeKey(r.pop()); let s = "", a = r.indexOf("code"); if (a > -1 && (r.splice(a, 1), s = "code."), Qy.forEach(l => { const c = r.indexOf(l); c > -1 && (r.splice(c, 1), s += l + ".") }), s += i, 0 != r.length || 0 === i.length) return null; const u = {}; return u.domEventName = o, u.fullKey = s, u } static matchEventFullKeyCode(n, r) { let o = oR[n.key] || n.key, i = ""; return r.indexOf("code.") > -1 && (o = n.code, i = "code."), !(null == o || !o) && (o = o.toLowerCase(), " " === o ? o = "space" : "." === o && (o = "dot"), Qy.forEach(s => { s !== o && (0, iR[s])(n) && (i += s + ".") }), i += o, i === r) } static eventCallback(n, r, o) { return i => { e.matchEventFullKeyCode(i, n) && o.runGuarded(() => r(i)) } } static _normalizeKey(n) { return "esc" === n ? "escape" : n } } return e.\u0275fac = function (n) { return new (n || e)(R(Ze)) }, e.\u0275prov = N({ token: e, factory: e.\u0275fac }), e })(); const cR = Zm(jM, "browser", [{ provide: Lm, useValue: "browser" }, { provide: km, useValue: function aR() { cc.makeCurrent() }, multi: !0 }, { provide: Ze, useFactory: function lR() { return function P_(e) { yu = e }(document), document }, deps: [] }]), Jy = new x(""), ev = [{ provide: ys, useClass: class ZA { addToWindow(t) { te.getAngularTestability = (r, o = !0) => { const i = t.findTestabilityInTree(r, o); if (null == i) throw new Error("Could not find testability for element."); return i }, te.getAllAngularTestabilities = () => t.getAllTestabilities(), te.getAllAngularRootElements = () => t.getAllRootElements(), te.frameworkStabilizers || (te.frameworkStabilizers = []), te.frameworkStabilizers.push(r => { const o = te.getAllAngularTestabilities(); let i = o.length, s = !1; const a = function (u) { s = s || u, i--, 0 == i && r(s) }; o.forEach(function (u) { u.whenStable(a) }) }) } findTestabilityInTree(t, n, r) { return null == n ? null : t.getTestability(n) ?? (r ? jn().isShadowRoot(n) ? this.findTestabilityInTree(t, n.host, !0) : this.findTestabilityInTree(t, n.parentElement, !0) : null) } }, deps: [] }, { provide: Hm, useClass: Nl, deps: [ce, Ol, ys] }, { provide: Nl, useClass: Nl, deps: [ce, Ol, ys] }], tv = [{ provide: Iu, useValue: "root" }, { provide: fr, useFactory: function uR() { return new fr }, deps: [] }, { provide: Fs, useClass: rR, multi: !0, deps: [Ze, ce, Lm] }, { provide: Fs, useClass: sR, multi: !0, deps: [Ze] }, { provide: hc, useClass: hc, deps: [ks, Lo, xo, zy] }, { provide: Th, useExisting: hc }, { provide: Uy, useExisting: Lo }, { provide: Lo, useClass: Lo, deps: [Ze] }, { provide: ks, useClass: ks, deps: [Fs, ce] }, { provide: class mA { }, useClass: YA, deps: [] }, []]; let dR = (() => { class e { constructor(n) { } static withServerTransition(n) { return { ngModule: e, providers: [{ provide: xo, useValue: n.appId }, { provide: $y, useExisting: xo }, qA] } } } return e.\u0275fac = function (n) { return new (n || e)(R(Jy, 12)) }, e.\u0275mod = bn({ type: e }), e.\u0275inj = un({ providers: [...tv, ...ev], imports: [lA, $M] }), e })(), nv = (() => { class e { constructor(n) { this._doc = n } getTitle() { return this._doc.title } setTitle(n) { this._doc.title = n || "" } } return e.\u0275fac = function (n) { return new (n || e)(R(Ze)) }, e.\u0275prov = N({ token: e, factory: function (n) { let r = null; return r = n ? new n : function hR() { return new nv(R(Ze)) }(), r }, providedIn: "root" }), e })(); function M(...e) { return ve(e, zr(e)) } typeof window < "u" && window; class St extends Vt { constructor(t) { super(), this._value = t } get value() { return this.getValue() } _subscribe(t) { const n = super._subscribe(t); return !n.closed && t.next(this._value), n } getValue() { const { hasError: t, thrownError: n, _value: r } = this; if (t) throw n; return this._throwIfClosed(), r } next(t) { super.next(this._value = t) } } const Ls = Ur(e => function () { e(this), this.name = "EmptyError", this.message = "no elements in sequence" }), { isArray: DR } = Array, { getPrototypeOf: wR, prototype: CR, keys: _R } = Object; const { isArray: SR } = Array; function iv(...e) { const t = zr(e), n = function uw(e) { return X(pa(e)) ? e.pop() : void 0 }(e), { args: r, keys: o } = function ER(e) { if (1 === e.length) { const t = e[0]; if (DR(t)) return { args: t, keys: null }; if (function bR(e) { return e && "object" == typeof e && wR(e) === CR }(t)) { const n = _R(t); return { args: n.map(r => t[r]), keys: n } } } return { args: e, keys: null } }(e); if (0 === r.length) return ve([], t); const i = new ye(function AR(e, t, n = En) { return r => { sv(t, () => { const { length: o } = e, i = new Array(o); let s = o, a = o; for (let u = 0; u < o; u++)sv(t, () => { const l = ve(e[u], t); let c = !1; l.subscribe(Ee(r, d => { i[u] = d, c || (c = !0, a--), a || r.next(n(i.slice())) }, () => { --s || r.complete() })) }, r) }, r) } }(r, t, o ? s => function TR(e, t) { return e.reduce((n, r, o) => (n[r] = t[o], n), {}) }(o, s) : En)); return n ? i.pipe(function MR(e) { return H(t => function IR(e, t) { return SR(t) ? e(...t) : e(t) }(e, t)) }(n)) : i } function sv(e, t, n) { e ? Ut(n, e, t) : t() } function vc(...e) { return function RR() { return Gn(1) }()(ve(e, zr(e))) } function av(e) { return new ye(t => { pt(e()).subscribe(t) }) } function jo(e, t) { const n = X(e) ? e : () => e, r = o => o.error(n()); return new ye(t ? o => t.schedule(r, 0, o) : r) } function Dc() { return _e((e, t) => { let n = null; e._refCount++; const r = Ee(t, void 0, void 0, void 0, () => { if (!e || e._refCount <= 0 || 0 < --e._refCount) return void (n = null); const o = e._connection, i = n; n = null, o && (!i || o === i) && o.unsubscribe(), t.unsubscribe() }); e.subscribe(r), r.closed || (n = e.connect()) }) } class uv extends ye { constructor(t, n) { super(), this.source = t, this.subjectFactory = n, this._subject = null, this._refCount = 0, this._connection = null, rd(t) && (this.lift = t.lift) } _subscribe(t) { return this.getSubject().subscribe(t) } getSubject() { const t = this._subject; return (!t || t.isStopped) && (this._subject = this.subjectFactory()), this._subject } _teardown() { this._refCount = 0; const { _connection: t } = this; this._subject = this._connection = null, t?.unsubscribe() } connect() { let t = this._connection; if (!t) { t = this._connection = new it; const n = this.getSubject(); t.add(this.source.subscribe(Ee(n, void 0, () => { this._teardown(), n.complete() }, r => { this._teardown(), n.error(r) }, () => this._teardown()))), t.closed && (this._connection = null, t = it.EMPTY) } return t } refCount() { return Dc()(this) } } function Lt(e, t) { return _e((n, r) => { let o = null, i = 0, s = !1; const a = () => s && !o && r.complete(); n.subscribe(Ee(r, u => { o?.unsubscribe(); let l = 0; const c = i++; pt(e(u, c)).subscribe(o = Ee(r, d => r.next(t ? t(u, d, c, l++) : d), () => { o = null, a() })) }, () => { s = !0, a() })) }) } function xr(e) { return e <= 0 ? () => It : _e((t, n) => { let r = 0; t.subscribe(Ee(n, o => { ++r <= e && (n.next(o), e <= r && n.complete()) })) }) } function gn(e, t) { return _e((n, r) => { let o = 0; n.subscribe(Ee(r, i => e.call(t, i, o++) && r.next(i))) }) } function js(e) { return _e((t, n) => { let r = !1; t.subscribe(Ee(n, o => { r = !0, n.next(o) }, () => { r || n.next(e), n.complete() })) }) } function lv(e = PR) { return _e((t, n) => { let r = !1; t.subscribe(Ee(n, o => { r = !0, n.next(o) }, () => r ? n.complete() : n.error(e()))) }) } function PR() { return new Ls } function mn(e, t) { const n = arguments.length >= 2; return r => r.pipe(e ? gn((o, i) => e(o, i, r)) : En, xr(1), n ? js(t) : lv(() => new Ls)) } function Vn(e, t) { return X(t) ? be(e, t, 1) : be(e, 1) } function Fe(e, t, n) { const r = X(e) || t || n ? { next: e, error: t, complete: n } : e; return r ? _e((o, i) => { var s; null === (s = r.subscribe) || void 0 === s || s.call(r); let a = !0; o.subscribe(Ee(i, u => { var l; null === (l = r.next) || void 0 === l || l.call(r, u), i.next(u) }, () => { var u; a = !1, null === (u = r.complete) || void 0 === u || u.call(r), i.complete() }, u => { var l; a = !1, null === (l = r.error) || void 0 === l || l.call(r, u), i.error(u) }, () => { var u, l; a && (null === (u = r.unsubscribe) || void 0 === u || u.call(r)), null === (l = r.finalize) || void 0 === l || l.call(r) })) }) : En } function yn(e) { return _e((t, n) => { let i, r = null, o = !1; r = t.subscribe(Ee(n, void 0, void 0, s => { i = pt(e(s, yn(e)(t))), r ? (r.unsubscribe(), r = null, i.subscribe(n)) : o = !0 })), o && (r.unsubscribe(), r = null, i.subscribe(n)) }) } function cv(e, t) { return _e(function NR(e, t, n, r, o) { return (i, s) => { let a = n, u = t, l = 0; i.subscribe(Ee(s, c => { const d = l++; u = a ? e(u, c, d) : (a = !0, c), r && s.next(u) }, o && (() => { a && s.next(u), s.complete() }))) } }(e, t, arguments.length >= 2, !0)) } function wc(e) { return e <= 0 ? () => It : _e((t, n) => { let r = []; t.subscribe(Ee(n, o => { r.push(o), e < r.length && r.shift() }, () => { for (const o of r) n.next(o); n.complete() }, void 0, () => { r = null })) }) } function dv(e, t) { const n = arguments.length >= 2; return r => r.pipe(e ? gn((o, i) => e(o, i, r)) : En, wc(1), n ? js(t) : lv(() => new Ls)) } function Cc(e) { return _e((t, n) => { try { t.subscribe(n) } finally { n.add(e) } }) } const L = "primary", $o = Symbol("RouteTitle"); class kR { constructor(t) { this.params = t || {} } has(t) { return Object.prototype.hasOwnProperty.call(this.params, t) } get(t) { if (this.has(t)) { const n = this.params[t]; return Array.isArray(n) ? n[0] : n } return null } getAll(t) { if (this.has(t)) { const n = this.params[t]; return Array.isArray(n) ? n : [n] } return [] } get keys() { return Object.keys(this.params) } } function Pr(e) { return new kR(e) } function LR(e, t, n) { const r = n.path.split("/"); if (r.length > e.length || "full" === n.pathMatch && (t.hasChildren() || r.length < e.length)) return null; const o = {}; for (let i = 0; i < r.length; i++) { const s = r[i], a = e[i]; if (s.startsWith(":")) o[s.substring(1)] = a; else if (s !== a.path) return null } return { consumed: e.slice(0, r.length), posParams: o } } function jt(e, t) { const n = e ? Object.keys(e) : void 0, r = t ? Object.keys(t) : void 0; if (!n || !r || n.length != r.length) return !1; let o; for (let i = 0; i < n.length; i++)if (o = n[i], !fv(e[o], t[o])) return !1; return !0 } function fv(e, t) { if (Array.isArray(e) && Array.isArray(t)) { if (e.length !== t.length) return !1; const n = [...e].sort(), r = [...t].sort(); return n.every((o, i) => r[i] === o) } return e === t } function hv(e) { return Array.prototype.concat.apply([], e) } function pv(e) { return e.length > 0 ? e[e.length - 1] : null } function Me(e, t) { for (const n in e) e.hasOwnProperty(n) && t(e[n], n) } function vn(e) { return Sp(e) ? e : ts(e) ? ve(Promise.resolve(e)) : M(e) } const $s = !1, $R = { exact: function yv(e, t, n) { if (!Un(e.segments, t.segments) || !Vs(e.segments, t.segments, n) || e.numberOfChildren !== t.numberOfChildren) return !1; for (const r in t.children) if (!e.children[r] || !yv(e.children[r], t.children[r], n)) return !1; return !0 }, subset: vv }, gv = { exact: function VR(e, t) { return jt(e, t) }, subset: function UR(e, t) { return Object.keys(t).length <= Object.keys(e).length && Object.keys(t).every(n => fv(e[n], t[n])) }, ignored: () => !0 }; function mv(e, t, n) { return $R[n.paths](e.root, t.root, n.matrixParams) && gv[n.queryParams](e.queryParams, t.queryParams) && !("exact" === n.fragment && e.fragment !== t.fragment) } function vv(e, t, n) { return Dv(e, t, t.segments, n) } function Dv(e, t, n, r) { if (e.segments.length > n.length) { const o = e.segments.slice(0, n.length); return !(!Un(o, n) || t.hasChildren() || !Vs(o, n, r)) } if (e.segments.length === n.length) { if (!Un(e.segments, n) || !Vs(e.segments, n, r)) return !1; for (const o in t.children) if (!e.children[o] || !vv(e.children[o], t.children[o], r)) return !1; return !0 } { const o = n.slice(0, e.segments.length), i = n.slice(e.segments.length); return !!(Un(e.segments, o) && Vs(e.segments, o, r) && e.children[L]) && Dv(e.children[L], t, i, r) } } function Vs(e, t, n) { return t.every((r, o) => gv[n](e[o].parameters, r.parameters)) } class Dn { constructor(t = new U([], {}), n = {}, r = null) { this.root = t, this.queryParams = n, this.fragment = r } get queryParamMap() { return this._queryParamMap || (this._queryParamMap = Pr(this.queryParams)), this._queryParamMap } toString() { return zR.serialize(this) } } class U { constructor(t, n) { this.segments = t, this.children = n, this.parent = null, Me(n, (r, o) => r.parent = this) } hasChildren() { return this.numberOfChildren > 0 } get numberOfChildren() { return Object.keys(this.children).length } toString() { return Us(this) } } class Vo { constructor(t, n) { this.path = t, this.parameters = n } get parameterMap() { return this._parameterMap || (this._parameterMap = Pr(this.parameters)), this._parameterMap } toString() { return _v(this) } } function Un(e, t) { return e.length === t.length && e.every((n, r) => n.path === t[r].path) } let Uo = (() => { class e { } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275prov = N({ token: e, factory: function () { return new _c }, providedIn: "root" }), e })(); class _c { parse(t) { const n = new JR(t); return new Dn(n.parseRootSegment(), n.parseQueryParams(), n.parseFragment()) } serialize(t) { const n = `/${Bo(t.root, !0)}`, r = function qR(e) { const t = Object.keys(e).map(n => { const r = e[n]; return Array.isArray(r) ? r.map(o => `${Bs(n)}=${Bs(o)}`).join("&") : `${Bs(n)}=${Bs(r)}` }).filter(n => !!n); return t.length ? `?${t.join("&")}` : "" }(t.queryParams); return `${n}${r}${"string" == typeof t.fragment ? `#${function GR(e) { return encodeURI(e) }(t.fragment)}` : ""}` } } const zR = new _c; function Us(e) { return e.segments.map(t => _v(t)).join("/") } function Bo(e, t) { if (!e.hasChildren()) return Us(e); if (t) { const n = e.children[L] ? Bo(e.children[L], !1) : "", r = []; return Me(e.children, (o, i) => { i !== L && r.push(`${i}:${Bo(o, !1)}`) }), r.length > 0 ? `${n}(${r.join("//")})` : n } { const n = function HR(e, t) { let n = []; return Me(e.children, (r, o) => { o === L && (n = n.concat(t(r, o))) }), Me(e.children, (r, o) => { o !== L && (n = n.concat(t(r, o))) }), n }(e, (r, o) => o === L ? [Bo(e.children[L], !1)] : [`${o}:${Bo(r, !1)}`]); return 1 === Object.keys(e.children).length && null != e.children[L] ? `${Us(e)}/${n[0]}` : `${Us(e)}/(${n.join("//")})` } } function wv(e) { return encodeURIComponent(e).replace(/%40/g, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",") } function Bs(e) { return wv(e).replace(/%3B/gi, ";") } function Ec(e) { return wv(e).replace(/\(/g, "%28").replace(/\)/g, "%29").replace(/%26/gi, "&") } function Hs(e) { return decodeURIComponent(e) } function Cv(e) { return Hs(e.replace(/\+/g, "%20")) } function _v(e) { return `${Ec(e.path)}${function WR(e) { return Object.keys(e).map(t => `;${Ec(t)}=${Ec(e[t])}`).join("") }(e.parameters)}` } const ZR = /^[^\/()?;=#]+/; function zs(e) { const t = e.match(ZR); return t ? t[0] : "" } const YR = /^[^=?&#]+/, KR = /^[^&#]+/; class JR { constructor(t) { this.url = t, this.remaining = t } parseRootSegment() { return this.consumeOptional("/"), "" === this.remaining || this.peekStartsWith("?") || this.peekStartsWith("#") ? new U([], {}) : new U([], this.parseChildren()) } parseQueryParams() { const t = {}; if (this.consumeOptional("?")) do { this.parseQueryParam(t) } while (this.consumeOptional("&")); return t } parseFragment() { return this.consumeOptional("#") ? decodeURIComponent(this.remaining) : null } parseChildren() { if ("" === this.remaining) return {}; this.consumeOptional("/"); const t = []; for (this.peekStartsWith("(") || t.push(this.parseSegment()); this.peekStartsWith("/") && !this.peekStartsWith("//") && !this.peekStartsWith("/(");)this.capture("/"), t.push(this.parseSegment()); let n = {}; this.peekStartsWith("/(") && (this.capture("/"), n = this.parseParens(!0)); let r = {}; return this.peekStartsWith("(") && (r = this.parseParens(!1)), (t.length > 0 || Object.keys(n).length > 0) && (r[L] = new U(t, n)), r } parseSegment() { const t = zs(this.remaining); if ("" === t && this.peekStartsWith(";")) throw new w(4009, $s); return this.capture(t), new Vo(Hs(t), this.parseMatrixParams()) } parseMatrixParams() { const t = {}; for (; this.consumeOptional(";");)this.parseParam(t); return t } parseParam(t) { const n = zs(this.remaining); if (!n) return; this.capture(n); let r = ""; if (this.consumeOptional("=")) { const o = zs(this.remaining); o && (r = o, this.capture(r)) } t[Hs(n)] = Hs(r) } parseQueryParam(t) { const n = function QR(e) { const t = e.match(YR); return t ? t[0] : "" }(this.remaining); if (!n) return; this.capture(n); let r = ""; if (this.consumeOptional("=")) { const s = function XR(e) { const t = e.match(KR); return t ? t[0] : "" }(this.remaining); s && (r = s, this.capture(r)) } const o = Cv(n), i = Cv(r); if (t.hasOwnProperty(o)) { let s = t[o]; Array.isArray(s) || (s = [s], t[o] = s), s.push(i) } else t[o] = i } parseParens(t) { const n = {}; for (this.capture("("); !this.consumeOptional(")") && this.remaining.length > 0;) { const r = zs(this.remaining), o = this.remaining[r.length]; if ("/" !== o && ")" !== o && ";" !== o) throw new w(4010, $s); let i; r.indexOf(":") > -1 ? (i = r.slice(0, r.indexOf(":")), this.capture(i), this.capture(":")) : t && (i = L); const s = this.parseChildren(); n[i] = 1 === Object.keys(s).length ? s[L] : new U([], s), this.consumeOptional("//") } return n } peekStartsWith(t) { return this.remaining.startsWith(t) } consumeOptional(t) { return !!this.peekStartsWith(t) && (this.remaining = this.remaining.substring(t.length), !0) } capture(t) { if (!this.consumeOptional(t)) throw new w(4011, $s) } } function bc(e) { return e.segments.length > 0 ? new U([], { [L]: e }) : e } function Gs(e) { const t = {}; for (const r of Object.keys(e.children)) { const i = Gs(e.children[r]); (i.segments.length > 0 || i.hasChildren()) && (t[r] = i) } return function ex(e) { if (1 === e.numberOfChildren && e.children[L]) { const t = e.children[L]; return new U(e.segments.concat(t.segments), t.children) } return e }(new U(e.segments, t)) } function Bn(e) { return e instanceof Dn } const Sc = !1; function tx(e, t, n, r, o) { if (0 === n.length) return Nr(t.root, t.root, t.root, r, o); const i = function Mv(e) { if ("string" == typeof e[0] && 1 === e.length && "/" === e[0]) return new Iv(!0, 0, e); let t = 0, n = !1; const r = e.reduce((o, i, s) => { if ("object" == typeof i && null != i) { if (i.outlets) { const a = {}; return Me(i.outlets, (u, l) => { a[l] = "string" == typeof u ? u.split("/") : u }), [...o, { outlets: a }] } if (i.segmentPath) return [...o, i.segmentPath] } return "string" != typeof i ? [...o, i] : 0 === s ? (i.split("/").forEach((a, u) => { 0 == u && "." === a || (0 == u && "" === a ? n = !0 : ".." === a ? t++ : "" != a && o.push(a)) }), o) : [...o, i] }, []); return new Iv(n, t, r) }(n); return i.toRoot() ? Nr(t.root, t.root, new U([], {}), r, o) : function s(u) { const l = function rx(e, t, n, r) { if (e.isAbsolute) return new Or(t.root, !0, 0); if (-1 === r) return new Or(n, n === t.root, 0); return function Tv(e, t, n) { let r = e, o = t, i = n; for (; i > o;) { if (i -= o, r = r.parent, !r) throw new w(4005, Sc && "Invalid number of './'"); o = r.segments.length } return new Or(r, !1, o - i) }(n, r + (Ho(e.commands[0]) ? 0 : 1), e.numberOfDoubleDots) }(i, t, e.snapshot?._urlSegment, u), c = l.processChildren ? Fr(l.segmentGroup, l.index, i.commands) : Ic(l.segmentGroup, l.index, i.commands); return Nr(t.root, l.segmentGroup, c, r, o) }(e.snapshot?._lastPathIndex) } function Ho(e) { return "object" == typeof e && null != e && !e.outlets && !e.segmentPath } function zo(e) { return "object" == typeof e && null != e && e.outlets } function Nr(e, t, n, r, o) { let s, i = {}; r && Me(r, (u, l) => { i[l] = Array.isArray(u) ? u.map(c => `${c}`) : `${u}` }), s = e === t ? n : Sv(e, t, n); const a = bc(Gs(s)); return new Dn(a, i, o) } function Sv(e, t, n) { const r = {}; return Me(e.children, (o, i) => { r[i] = o === t ? n : Sv(o, t, n) }), new U(e.segments, r) } class Iv { constructor(t, n, r) { if (this.isAbsolute = t, this.numberOfDoubleDots = n, this.commands = r, t && r.length > 0 && Ho(r[0])) throw new w(4003, Sc && "Root segment cannot have matrix parameters"); const o = r.find(zo); if (o && o !== pv(r)) throw new w(4004, Sc && "{outlets:{}} has to be the last command") } toRoot() { return this.isAbsolute && 1 === this.commands.length && "/" == this.commands[0] } } class Or { constructor(t, n, r) { this.segmentGroup = t, this.processChildren = n, this.index = r } } function Ic(e, t, n) { if (e || (e = new U([], {})), 0 === e.segments.length && e.hasChildren()) return Fr(e, t, n); const r = function ix(e, t, n) { let r = 0, o = t; const i = { match: !1, pathIndex: 0, commandIndex: 0 }; for (; o < e.segments.length;) { if (r >= n.length) return i; const s = e.segments[o], a = n[r]; if (zo(a)) break; const u = `${a}`, l = r < n.length - 1 ? n[r + 1] : null; if (o > 0 && void 0 === u) break; if (u && l && "object" == typeof l && void 0 === l.outlets) { if (!Rv(u, l, s)) return i; r += 2 } else { if (!Rv(u, {}, s)) return i; r++ } o++ } return { match: !0, pathIndex: o, commandIndex: r } }(e, t, n), o = n.slice(r.commandIndex); if (r.match && r.pathIndex < e.segments.length) { const i = new U(e.segments.slice(0, r.pathIndex), {}); return i.children[L] = new U(e.segments.slice(r.pathIndex), e.children), Fr(i, 0, o) } return r.match && 0 === o.length ? new U(e.segments, {}) : r.match && !e.hasChildren() ? Mc(e, t, n) : r.match ? Fr(e, 0, o) : Mc(e, t, n) } function Fr(e, t, n) { if (0 === n.length) return new U(e.segments, {}); { const r = function ox(e) { return zo(e[0]) ? e[0].outlets : { [L]: e } }(n), o = {}; if (!r[L] && e.children[L] && 1 === e.numberOfChildren && 0 === e.children[L].segments.length) { const i = Fr(e.children[L], t, n); return new U(e.segments, i.children) } return Me(r, (i, s) => { "string" == typeof i && (i = [i]), null !== i && (o[s] = Ic(e.children[s], t, i)) }), Me(e.children, (i, s) => { void 0 === r[s] && (o[s] = i) }), new U(e.segments, o) } } function Mc(e, t, n) { const r = e.segments.slice(0, t); let o = 0; for (; o < n.length;) { const i = n[o]; if (zo(i)) { const u = sx(i.outlets); return new U(r, u) } if (0 === o && Ho(n[0])) { r.push(new Vo(e.segments[t].path, Av(n[0]))), o++; continue } const s = zo(i) ? i.outlets[L] : `${i}`, a = o < n.length - 1 ? n[o + 1] : null; s && a && Ho(a) ? (r.push(new Vo(s, Av(a))), o += 2) : (r.push(new Vo(s, {})), o++) } return new U(r, {}) } function sx(e) { const t = {}; return Me(e, (n, r) => { "string" == typeof n && (n = [n]), null !== n && (t[r] = Mc(new U([], {}), 0, n)) }), t } function Av(e) { const t = {}; return Me(e, (n, r) => t[r] = `${n}`), t } function Rv(e, t, n) { return e == n.path && jt(t, n.parameters) } const Go = "imperative"; class $t { constructor(t, n) { this.id = t, this.url = n } } class Tc extends $t { constructor(t, n, r = "imperative", o = null) { super(t, n), this.type = 0, this.navigationTrigger = r, this.restoredState = o } toString() { return `NavigationStart(id: ${this.id}, url: '${this.url}')` } } class Hn extends $t { constructor(t, n, r) { super(t, n), this.urlAfterRedirects = r, this.type = 1 } toString() { return `NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')` } } class Ws extends $t { constructor(t, n, r, o) { super(t, n), this.reason = r, this.code = o, this.type = 2 } toString() { return `NavigationCancel(id: ${this.id}, url: '${this.url}')` } } class qs extends $t { constructor(t, n, r, o) { super(t, n), this.reason = r, this.code = o, this.type = 16 } } class Ac extends $t { constructor(t, n, r, o) { super(t, n), this.error = r, this.target = o, this.type = 3 } toString() { return `NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})` } } class ax extends $t { constructor(t, n, r, o) { super(t, n), this.urlAfterRedirects = r, this.state = o, this.type = 4 } toString() { return `RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class ux extends $t { constructor(t, n, r, o) { super(t, n), this.urlAfterRedirects = r, this.state = o, this.type = 7 } toString() { return `GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class lx extends $t { constructor(t, n, r, o, i) { super(t, n), this.urlAfterRedirects = r, this.state = o, this.shouldActivate = i, this.type = 8 } toString() { return `GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})` } } class cx extends $t { constructor(t, n, r, o) { super(t, n), this.urlAfterRedirects = r, this.state = o, this.type = 5 } toString() { return `ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class dx extends $t { constructor(t, n, r, o) { super(t, n), this.urlAfterRedirects = r, this.state = o, this.type = 6 } toString() { return `ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class fx { constructor(t) { this.route = t, this.type = 9 } toString() { return `RouteConfigLoadStart(path: ${this.route.path})` } } class hx { constructor(t) { this.route = t, this.type = 10 } toString() { return `RouteConfigLoadEnd(path: ${this.route.path})` } } class px { constructor(t) { this.snapshot = t, this.type = 11 } toString() { return `ChildActivationStart(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class gx { constructor(t) { this.snapshot = t, this.type = 12 } toString() { return `ChildActivationEnd(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class mx { constructor(t) { this.snapshot = t, this.type = 13 } toString() { return `ActivationStart(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class yx { constructor(t) { this.snapshot = t, this.type = 14 } toString() { return `ActivationEnd(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class xv { constructor(t, n, r) { this.routerEvent = t, this.position = n, this.anchor = r, this.type = 15 } toString() { return `Scroll(anchor: '${this.anchor}', position: '${this.position ? `${this.position[0]}, ${this.position[1]}` : null}')` } } let wx = (() => { class e { createUrlTree(n, r, o, i, s, a) { return tx(n || r.root, o, i, s, a) } } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275prov = N({ token: e, factory: e.\u0275fac }), e })(), _x = (() => { class e { } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275prov = N({ token: e, factory: function (t) { return wx.\u0275fac(t) }, providedIn: "root" }), e })(); class Pv { constructor(t) { this._root = t } get root() { return this._root.value } parent(t) { const n = this.pathFromRoot(t); return n.length > 1 ? n[n.length - 2] : null } children(t) { const n = Rc(t, this._root); return n ? n.children.map(r => r.value) : [] } firstChild(t) { const n = Rc(t, this._root); return n && n.children.length > 0 ? n.children[0].value : null } siblings(t) { const n = xc(t, this._root); return n.length < 2 ? [] : n[n.length - 2].children.map(o => o.value).filter(o => o !== t) } pathFromRoot(t) { return xc(t, this._root).map(n => n.value) } } function Rc(e, t) { if (e === t.value) return t; for (const n of t.children) { const r = Rc(e, n); if (r) return r } return null } function xc(e, t) { if (e === t.value) return [t]; for (const n of t.children) { const r = xc(e, n); if (r.length) return r.unshift(t), r } return [] } class on { constructor(t, n) { this.value = t, this.children = n } toString() { return `TreeNode(${this.value})` } } function kr(e) { const t = {}; return e && e.children.forEach(n => t[n.value.outlet] = n), t } class Nv extends Pv { constructor(t, n) { super(t), this.snapshot = n, Pc(this, t) } toString() { return this.snapshot.toString() } } function Ov(e, t) { const n = function Ex(e, t) { const s = new Zs([], {}, {}, "", {}, L, t, null, e.root, -1, {}); return new kv("", new on(s, [])) }(e, t), r = new St([new Vo("", {})]), o = new St({}), i = new St({}), s = new St({}), a = new St(""), u = new zn(r, o, s, a, i, L, t, n.root); return u.snapshot = n.root, new Nv(new on(u, []), n) } class zn { constructor(t, n, r, o, i, s, a, u) { this.url = t, this.params = n, this.queryParams = r, this.fragment = o, this.data = i, this.outlet = s, this.component = a, this.title = this.data?.pipe(H(l => l[$o])) ?? M(void 0), this._futureSnapshot = u } get routeConfig() { return this._futureSnapshot.routeConfig } get root() { return this._routerState.root } get parent() { return this._routerState.parent(this) } get firstChild() { return this._routerState.firstChild(this) } get children() { return this._routerState.children(this) } get pathFromRoot() { return this._routerState.pathFromRoot(this) } get paramMap() { return this._paramMap || (this._paramMap = this.params.pipe(H(t => Pr(t)))), this._paramMap } get queryParamMap() { return this._queryParamMap || (this._queryParamMap = this.queryParams.pipe(H(t => Pr(t)))), this._queryParamMap } toString() { return this.snapshot ? this.snapshot.toString() : `Future(${this._futureSnapshot})` } } function Fv(e, t = "emptyOnly") { const n = e.pathFromRoot; let r = 0; if ("always" !== t) for (r = n.length - 1; r >= 1;) { const o = n[r], i = n[r - 1]; if (o.routeConfig && "" === o.routeConfig.path) r--; else { if (i.component) break; r-- } } return function bx(e) { return e.reduce((t, n) => ({ params: { ...t.params, ...n.params }, data: { ...t.data, ...n.data }, resolve: { ...n.data, ...t.resolve, ...n.routeConfig?.data, ...n._resolvedData } }), { params: {}, data: {}, resolve: {} }) }(n.slice(r)) } class Zs { get title() { return this.data?.[$o] } constructor(t, n, r, o, i, s, a, u, l, c, d) { this.url = t, this.params = n, this.queryParams = r, this.fragment = o, this.data = i, this.outlet = s, this.component = a, this.routeConfig = u, this._urlSegment = l, this._lastPathIndex = c, this._resolve = d } get root() { return this._routerState.root } get parent() { return this._routerState.parent(this) } get firstChild() { return this._routerState.firstChild(this) } get children() { return this._routerState.children(this) } get pathFromRoot() { return this._routerState.pathFromRoot(this) } get paramMap() { return this._paramMap || (this._paramMap = Pr(this.params)), this._paramMap } get queryParamMap() { return this._queryParamMap || (this._queryParamMap = Pr(this.queryParams)), this._queryParamMap } toString() { return `Route(url:'${this.url.map(r => r.toString()).join("/")}', path:'${this.routeConfig ? this.routeConfig.path : ""}')` } } class kv extends Pv { constructor(t, n) { super(n), this.url = t, Pc(this, n) } toString() { return Lv(this._root) } } function Pc(e, t) { t.value._routerState = e, t.children.forEach(n => Pc(e, n)) } function Lv(e) { const t = e.children.length > 0 ? ` { ${e.children.map(Lv).join(", ")} } ` : ""; return `${e.value}${t}` } function Nc(e) { if (e.snapshot) { const t = e.snapshot, n = e._futureSnapshot; e.snapshot = n, jt(t.queryParams, n.queryParams) || e.queryParams.next(n.queryParams), t.fragment !== n.fragment && e.fragment.next(n.fragment), jt(t.params, n.params) || e.params.next(n.params), function jR(e, t) { if (e.length !== t.length) return !1; for (let n = 0; n < e.length; ++n)if (!jt(e[n], t[n])) return !1; return !0 }(t.url, n.url) || e.url.next(n.url), jt(t.data, n.data) || e.data.next(n.data) } else e.snapshot = e._futureSnapshot, e.data.next(e._futureSnapshot.data) } function Oc(e, t) { const n = jt(e.params, t.params) && function BR(e, t) { return Un(e, t) && e.every((n, r) => jt(n.parameters, t[r].parameters)) }(e.url, t.url); return n && !(!e.parent != !t.parent) && (!e.parent || Oc(e.parent, t.parent)) } function Wo(e, t, n) { if (n && e.shouldReuseRoute(t.value, n.value.snapshot)) { const r = n.value; r._futureSnapshot = t.value; const o = function Ix(e, t, n) { return t.children.map(r => { for (const o of n.children) if (e.shouldReuseRoute(r.value, o.value.snapshot)) return Wo(e, r, o); return Wo(e, r) }) }(e, t, n); return new on(r, o) } { if (e.shouldAttach(t.value)) { const i = e.retrieve(t.value); if (null !== i) { const s = i.route; return s.value._futureSnapshot = t.value, s.children = t.children.map(a => Wo(e, a)), s } } const r = function Mx(e) { return new zn(new St(e.url), new St(e.params), new St(e.queryParams), new St(e.fragment), new St(e.data), e.outlet, e.component, e) }(t.value), o = t.children.map(i => Wo(e, i)); return new on(r, o) } } const Fc = "ngNavigationCancelingError"; function jv(e, t) { const { redirectTo: n, navigationBehaviorOptions: r } = Bn(t) ? { redirectTo: t, navigationBehaviorOptions: void 0 } : t, o = $v(!1, 0, t); return o.url = n, o.navigationBehaviorOptions = r, o } function $v(e, t, n) { const r = new Error("NavigationCancelingError: " + (e || "")); return r[Fc] = !0, r.cancellationCode = t, n && (r.url = n), r } function Vv(e) { return Uv(e) && Bn(e.url) } function Uv(e) { return e && e[Fc] } class Tx { constructor() { this.outlet = null, this.route = null, this.resolver = null, this.injector = null, this.children = new qo, this.attachRef = null } } let qo = (() => { class e { constructor() { this.contexts = new Map } onChildOutletCreated(n, r) { const o = this.getOrCreateContext(n); o.outlet = r, this.contexts.set(n, o) } onChildOutletDestroyed(n) { const r = this.getContext(n); r && (r.outlet = null, r.attachRef = null) } onOutletDeactivated() { const n = this.contexts; return this.contexts = new Map, n } onOutletReAttached(n) { this.contexts = n } getOrCreateContext(n) { let r = this.getContext(n); return r || (r = new Tx, this.contexts.set(n, r)), r } getContext(n) { return this.contexts.get(n) || null } } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275prov = N({ token: e, factory: e.\u0275fac, providedIn: "root" }), e })(); const Ys = !1; let kc = (() => { class e { constructor() { this.activated = null, this._activatedRoute = null, this.name = L, this.activateEvents = new Oe, this.deactivateEvents = new Oe, this.attachEvents = new Oe, this.detachEvents = new Oe, this.parentContexts = z(qo), this.location = z(Ct), this.changeDetector = z(jl), this.environmentInjector = z(Yt) } ngOnChanges(n) { if (n.name) { const { firstChange: r, previousValue: o } = n.name; if (r) return; this.isTrackedInParentContexts(o) && (this.deactivate(), this.parentContexts.onChildOutletDestroyed(o)), this.initializeOutletWithName() } } ngOnDestroy() { this.isTrackedInParentContexts(this.name) && this.parentContexts.onChildOutletDestroyed(this.name) } isTrackedInParentContexts(n) { return this.parentContexts.getContext(n)?.outlet === this } ngOnInit() { this.initializeOutletWithName() } initializeOutletWithName() { if (this.parentContexts.onChildOutletCreated(this.name, this), this.activated) return; const n = this.parentContexts.getContext(this.name); n?.route && (n.attachRef ? this.attach(n.attachRef, n.route) : this.activateWith(n.route, n.injector)) } get isActivated() { return !!this.activated } get component() { if (!this.activated) throw new w(4012, Ys); return this.activated.instance } get activatedRoute() { if (!this.activated) throw new w(4012, Ys); return this._activatedRoute } get activatedRouteData() { return this._activatedRoute ? this._activatedRoute.snapshot.data : {} } detach() { if (!this.activated) throw new w(4012, Ys); this.location.detach(); const n = this.activated; return this.activated = null, this._activatedRoute = null, this.detachEvents.emit(n.instance), n } attach(n, r) { this.activated = n, this._activatedRoute = r, this.location.insert(n.hostView), this.attachEvents.emit(n.instance) } deactivate() { if (this.activated) { const n = this.component; this.activated.destroy(), this.activated = null, this._activatedRoute = null, this.deactivateEvents.emit(n) } } activateWith(n, r) { if (this.isActivated) throw new w(4013, Ys); this._activatedRoute = n; const o = this.location, s = n.snapshot.component, a = this.parentContexts.getOrCreateContext(this.name).children, u = new Ax(n, a, o.injector); if (r && function Rx(e) { return !!e.resolveComponentFactory }(r)) { const l = r.resolveComponentFactory(s); this.activated = o.createComponent(l, o.length, u) } else this.activated = o.createComponent(s, { index: o.length, injector: u, environmentInjector: r ?? this.environmentInjector }); this.changeDetector.markForCheck(), this.activateEvents.emit(this.activated.instance) } } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275dir = ke({ type: e, selectors: [["router-outlet"]], inputs: { name: "name" }, outputs: { activateEvents: "activate", deactivateEvents: "deactivate", attachEvents: "attach", detachEvents: "detach" }, exportAs: ["outlet"], standalone: !0, features: [Mn] }), e })(); class Ax { constructor(t, n, r) { this.route = t, this.childContexts = n, this.parent = r } get(t, n) { return t === zn ? this.route : t === qo ? this.childContexts : this.parent.get(t, n) } } let Lc = (() => { class e { } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275cmp = Yr({ type: e, selectors: [["ng-component"]], standalone: !0, features: [Yg], decls: 1, vars: 0, template: function (n, r) { 1 & n && Ne(0, "router-outlet") }, dependencies: [kc], encapsulation: 2 }), e })(); function Bv(e, t) { return e.providers && !e._injector && (e._injector = cs(e.providers, t, `Route: ${e.path}`)), e._injector ?? t } function $c(e) { const t = e.children && e.children.map($c), n = t ? { ...e, children: t } : { ...e }; return !n.component && !n.loadComponent && (t || n.loadChildren) && n.outlet && n.outlet !== L && (n.component = Lc), n } function ht(e) { return e.outlet || L } function Hv(e, t) { const n = e.filter(r => ht(r) === t); return n.push(...e.filter(r => ht(r) !== t)), n } function Zo(e) { if (!e) return null; if (e.routeConfig?._injector) return e.routeConfig._injector; for (let t = e.parent; t; t = t.parent) { const n = t.routeConfig; if (n?._loadedInjector) return n._loadedInjector; if (n?._injector) return n._injector } return null } class Fx { constructor(t, n, r, o) { this.routeReuseStrategy = t, this.futureState = n, this.currState = r, this.forwardEvent = o } activate(t) { const n = this.futureState._root, r = this.currState ? this.currState._root : null; this.deactivateChildRoutes(n, r, t), Nc(this.futureState.root), this.activateChildRoutes(n, r, t) } deactivateChildRoutes(t, n, r) { const o = kr(n); t.children.forEach(i => { const s = i.value.outlet; this.deactivateRoutes(i, o[s], r), delete o[s] }), Me(o, (i, s) => { this.deactivateRouteAndItsChildren(i, r) }) } deactivateRoutes(t, n, r) { const o = t.value, i = n ? n.value : null; if (o === i) if (o.component) { const s = r.getContext(o.outlet); s && this.deactivateChildRoutes(t, n, s.children) } else this.deactivateChildRoutes(t, n, r); else i && this.deactivateRouteAndItsChildren(n, r) } deactivateRouteAndItsChildren(t, n) { t.value.component && this.routeReuseStrategy.shouldDetach(t.value.snapshot) ? this.detachAndStoreRouteSubtree(t, n) : this.deactivateRouteAndOutlet(t, n) } detachAndStoreRouteSubtree(t, n) { const r = n.getContext(t.value.outlet), o = r && t.value.component ? r.children : n, i = kr(t); for (const s of Object.keys(i)) this.deactivateRouteAndItsChildren(i[s], o); if (r && r.outlet) { const s = r.outlet.detach(), a = r.children.onOutletDeactivated(); this.routeReuseStrategy.store(t.value.snapshot, { componentRef: s, route: t, contexts: a }) } } deactivateRouteAndOutlet(t, n) { const r = n.getContext(t.value.outlet), o = r && t.value.component ? r.children : n, i = kr(t); for (const s of Object.keys(i)) this.deactivateRouteAndItsChildren(i[s], o); r && (r.outlet && (r.outlet.deactivate(), r.children.onOutletDeactivated()), r.attachRef = null, r.resolver = null, r.route = null) } activateChildRoutes(t, n, r) { const o = kr(n); t.children.forEach(i => { this.activateRoutes(i, o[i.value.outlet], r), this.forwardEvent(new yx(i.value.snapshot)) }), t.children.length && this.forwardEvent(new gx(t.value.snapshot)) } activateRoutes(t, n, r) { const o = t.value, i = n ? n.value : null; if (Nc(o), o === i) if (o.component) { const s = r.getOrCreateContext(o.outlet); this.activateChildRoutes(t, n, s.children) } else this.activateChildRoutes(t, n, r); else if (o.component) { const s = r.getOrCreateContext(o.outlet); if (this.routeReuseStrategy.shouldAttach(o.snapshot)) { const a = this.routeReuseStrategy.retrieve(o.snapshot); this.routeReuseStrategy.store(o.snapshot, null), s.children.onOutletReAttached(a.contexts), s.attachRef = a.componentRef, s.route = a.route.value, s.outlet && s.outlet.attach(a.componentRef, a.route.value), Nc(a.route.value), this.activateChildRoutes(t, null, s.children) } else { const a = Zo(o.snapshot), u = a?.get(yo) ?? null; s.attachRef = null, s.route = o, s.resolver = u, s.injector = a, s.outlet && s.outlet.activateWith(o, s.injector), this.activateChildRoutes(t, null, s.children) } } else this.activateChildRoutes(t, null, r) } } class zv { constructor(t) { this.path = t, this.route = this.path[this.path.length - 1] } } class Qs { constructor(t, n) { this.component = t, this.route = n } } function kx(e, t, n) { const r = e._root; return Yo(r, t ? t._root : null, n, [r.value]) } function Lr(e, t) { const n = Symbol(), r = t.get(e, n); return r === n ? "function" != typeof e || function bw(e) { return null !== ai(e) }(e) ? t.get(e) : e : r } function Yo(e, t, n, r, o = { canDeactivateChecks: [], canActivateChecks: [] }) { const i = kr(t); return e.children.forEach(s => { (function jx(e, t, n, r, o = { canDeactivateChecks: [], canActivateChecks: [] }) { const i = e.value, s = t ? t.value : null, a = n ? n.getContext(e.value.outlet) : null; if (s && i.routeConfig === s.routeConfig) { const u = function $x(e, t, n) { if ("function" == typeof n) return n(e, t); switch (n) { case "pathParamsChange": return !Un(e.url, t.url); case "pathParamsOrQueryParamsChange": return !Un(e.url, t.url) || !jt(e.queryParams, t.queryParams); case "always": return !0; case "paramsOrQueryParamsChange": return !Oc(e, t) || !jt(e.queryParams, t.queryParams); default: return !Oc(e, t) } }(s, i, i.routeConfig.runGuardsAndResolvers); u ? o.canActivateChecks.push(new zv(r)) : (i.data = s.data, i._resolvedData = s._resolvedData), Yo(e, t, i.component ? a ? a.children : null : n, r, o), u && a && a.outlet && a.outlet.isActivated && o.canDeactivateChecks.push(new Qs(a.outlet.component, s)) } else s && Qo(t, a, o), o.canActivateChecks.push(new zv(r)), Yo(e, null, i.component ? a ? a.children : null : n, r, o) })(s, i[s.value.outlet], n, r.concat([s.value]), o), delete i[s.value.outlet] }), Me(i, (s, a) => Qo(s, n.getContext(a), o)), o } function Qo(e, t, n) { const r = kr(e), o = e.value; Me(r, (i, s) => { Qo(i, o.component ? t ? t.children.getContext(s) : null : t, n) }), n.canDeactivateChecks.push(new Qs(o.component && t && t.outlet && t.outlet.isActivated ? t.outlet.component : null, o)) } function Ko(e) { return "function" == typeof e } function Vc(e) { return e instanceof Ls || "EmptyError" === e?.name } const Ks = Symbol("INITIAL_VALUE"); function jr() { return Lt(e => iv(e.map(t => t.pipe(xr(1), function xR(...e) { const t = zr(e); return _e((n, r) => { (t ? vc(e, n, t) : vc(e, n)).subscribe(r) }) }(Ks)))).pipe(H(t => { for (const n of t) if (!0 !== n) { if (n === Ks) return Ks; if (!1 === n || n instanceof Dn) return n } return !0 }), gn(t => t !== Ks), xr(1))) } function Gv(e) { return function ID(...e) { return ed(e) }(Fe(t => { if (Bn(t)) throw jv(0, t) }), H(t => !0 === t)) } const Uc = { matched: !1, consumedSegments: [], remainingSegments: [], parameters: {}, positionalParamSegments: {} }; function Wv(e, t, n, r, o) { const i = Bc(e, t, n); return i.matched ? function nP(e, t, n, r) { const o = t.canMatch; return o && 0 !== o.length ? M(o.map(s => { const a = Lr(s, e); return vn(function Gx(e) { return e && Ko(e.canMatch) }(a) ? a.canMatch(t, n) : e.runInContext(() => a(t, n))) })).pipe(jr(), Gv()) : M(!0) }(r = Bv(t, r), t, n).pipe(H(s => !0 === s ? i : { ...Uc })) : M(i) } function Bc(e, t, n) { if ("" === t.path) return "full" === t.pathMatch && (e.hasChildren() || n.length > 0) ? { ...Uc } : { matched: !0, consumedSegments: [], remainingSegments: n, parameters: {}, positionalParamSegments: {} }; const o = (t.matcher || LR)(n, e, t); if (!o) return { ...Uc }; const i = {}; Me(o.posParams, (a, u) => { i[u] = a.path }); const s = o.consumed.length > 0 ? { ...i, ...o.consumed[o.consumed.length - 1].parameters } : i; return { matched: !0, consumedSegments: o.consumed, remainingSegments: n.slice(o.consumed.length), parameters: s, positionalParamSegments: o.posParams ?? {} } } function Xs(e, t, n, r) { if (n.length > 0 && function iP(e, t, n) { return n.some(r => Js(e, t, r) && ht(r) !== L) }(e, n, r)) { const i = new U(t, function oP(e, t, n, r) { const o = {}; o[L] = r, r._sourceSegment = e, r._segmentIndexShift = t.length; for (const i of n) if ("" === i.path && ht(i) !== L) { const s = new U([], {}); s._sourceSegment = e, s._segmentIndexShift = t.length, o[ht(i)] = s } return o }(e, t, r, new U(n, e.children))); return i._sourceSegment = e, i._segmentIndexShift = t.length, { segmentGroup: i, slicedSegments: [] } } if (0 === n.length && function sP(e, t, n) { return n.some(r => Js(e, t, r)) }(e, n, r)) { const i = new U(e.segments, function rP(e, t, n, r, o) { const i = {}; for (const s of r) if (Js(e, n, s) && !o[ht(s)]) { const a = new U([], {}); a._sourceSegment = e, a._segmentIndexShift = t.length, i[ht(s)] = a } return { ...o, ...i } }(e, t, n, r, e.children)); return i._sourceSegment = e, i._segmentIndexShift = t.length, { segmentGroup: i, slicedSegments: n } } const o = new U(e.segments, e.children); return o._sourceSegment = e, o._segmentIndexShift = t.length, { segmentGroup: o, slicedSegments: n } } function Js(e, t, n) { return (!(e.hasChildren() || t.length > 0) || "full" !== n.pathMatch) && "" === n.path } function qv(e, t, n, r) { return !!(ht(e) === r || r !== L && Js(t, n, e)) && ("**" === e.path || Bc(t, e, n).matched) } function Zv(e, t, n) { return 0 === t.length && !e.children[n] } const ea = !1; class ta { constructor(t) { this.segmentGroup = t || null } } class Yv { constructor(t) { this.urlTree = t } } function Xo(e) { return jo(new ta(e)) } function Qv(e) { return jo(new Yv(e)) } class cP { constructor(t, n, r, o, i) { this.injector = t, this.configLoader = n, this.urlSerializer = r, this.urlTree = o, this.config = i, this.allowRedirects = !0 } apply() { const t = Xs(this.urlTree.root, [], [], this.config).segmentGroup, n = new U(t.segments, t.children); return this.expandSegmentGroup(this.injector, this.config, n, L).pipe(H(i => this.createUrlTree(Gs(i), this.urlTree.queryParams, this.urlTree.fragment))).pipe(yn(i => { if (i instanceof Yv) return this.allowRedirects = !1, this.match(i.urlTree); throw i instanceof ta ? this.noMatchError(i) : i })) } match(t) { return this.expandSegmentGroup(this.injector, this.config, t.root, L).pipe(H(o => this.createUrlTree(Gs(o), t.queryParams, t.fragment))).pipe(yn(o => { throw o instanceof ta ? this.noMatchError(o) : o })) } noMatchError(t) { return new w(4002, ea) } createUrlTree(t, n, r) { const o = bc(t); return new Dn(o, n, r) } expandSegmentGroup(t, n, r, o) { return 0 === r.segments.length && r.hasChildren() ? this.expandChildren(t, n, r).pipe(H(i => new U([], i))) : this.expandSegment(t, r, n, r.segments, o, !0) } expandChildren(t, n, r) { const o = []; for (const i of Object.keys(r.children)) "primary" === i ? o.unshift(i) : o.push(i); return ve(o).pipe(Vn(i => { const s = r.children[i], a = Hv(n, i); return this.expandSegmentGroup(t, a, s, i).pipe(H(u => ({ segment: u, outlet: i }))) }), cv((i, s) => (i[s.outlet] = s.segment, i), {}), dv()) } expandSegment(t, n, r, o, i, s) { return ve(r).pipe(Vn(a => this.expandSegmentAgainstRoute(t, n, r, a, o, i, s).pipe(yn(l => { if (l instanceof ta) return M(null); throw l }))), mn(a => !!a), yn((a, u) => { if (Vc(a)) return Zv(n, o, i) ? M(new U([], {})) : Xo(n); throw a })) } expandSegmentAgainstRoute(t, n, r, o, i, s, a) { return qv(o, n, i, s) ? void 0 === o.redirectTo ? this.matchSegmentAgainstRoute(t, n, o, i, s) : a && this.allowRedirects ? this.expandSegmentAgainstRouteUsingRedirect(t, n, r, o, i, s) : Xo(n) : Xo(n) } expandSegmentAgainstRouteUsingRedirect(t, n, r, o, i, s) { return "**" === o.path ? this.expandWildCardWithParamsAgainstRouteUsingRedirect(t, r, o, s) : this.expandRegularSegmentAgainstRouteUsingRedirect(t, n, r, o, i, s) } expandWildCardWithParamsAgainstRouteUsingRedirect(t, n, r, o) { const i = this.applyRedirectCommands([], r.redirectTo, {}); return r.redirectTo.startsWith("/") ? Qv(i) : this.lineralizeSegments(r, i).pipe(be(s => { const a = new U(s, {}); return this.expandSegment(t, a, n, s, o, !1) })) } expandRegularSegmentAgainstRouteUsingRedirect(t, n, r, o, i, s) { const { matched: a, consumedSegments: u, remainingSegments: l, positionalParamSegments: c } = Bc(n, o, i); if (!a) return Xo(n); const d = this.applyRedirectCommands(u, o.redirectTo, c); return o.redirectTo.startsWith("/") ? Qv(d) : this.lineralizeSegments(o, d).pipe(be(f => this.expandSegment(t, n, r, f.concat(l), s, !1))) } matchSegmentAgainstRoute(t, n, r, o, i) { return "**" === r.path ? (t = Bv(r, t), r.loadChildren ? (r._loadedRoutes ? M({ routes: r._loadedRoutes, injector: r._loadedInjector }) : this.configLoader.loadChildren(t, r)).pipe(H(a => (r._loadedRoutes = a.routes, r._loadedInjector = a.injector, new U(o, {})))) : M(new U(o, {}))) : Wv(n, r, o, t).pipe(Lt(({ matched: s, consumedSegments: a, remainingSegments: u }) => s ? this.getChildConfig(t = r._injector ?? t, r, o).pipe(be(c => { const d = c.injector ?? t, f = c.routes, { segmentGroup: h, slicedSegments: p } = Xs(n, a, u, f), g = new U(h.segments, h.children); if (0 === p.length && g.hasChildren()) return this.expandChildren(d, f, g).pipe(H(m => new U(a, m))); if (0 === f.length && 0 === p.length) return M(new U(a, {})); const y = ht(r) === i; return this.expandSegment(d, g, f, p, y ? L : i, !0).pipe(H(_ => new U(a.concat(_.segments), _.children))) })) : Xo(n))) } getChildConfig(t, n, r) { return n.children ? M({ routes: n.children, injector: t }) : n.loadChildren ? void 0 !== n._loadedRoutes ? M({ routes: n._loadedRoutes, injector: n._loadedInjector }) : function tP(e, t, n, r) { const o = t.canLoad; return void 0 === o || 0 === o.length ? M(!0) : M(o.map(s => { const a = Lr(s, e); return vn(function Ux(e) { return e && Ko(e.canLoad) }(a) ? a.canLoad(t, n) : e.runInContext(() => a(t, n))) })).pipe(jr(), Gv()) }(t, n, r).pipe(be(o => o ? this.configLoader.loadChildren(t, n).pipe(Fe(i => { n._loadedRoutes = i.routes, n._loadedInjector = i.injector })) : function uP(e) { return jo($v(ea, 3)) }())) : M({ routes: [], injector: t }) } lineralizeSegments(t, n) { let r = [], o = n.root; for (; ;) { if (r = r.concat(o.segments), 0 === o.numberOfChildren) return M(r); if (o.numberOfChildren > 1 || !o.children[L]) return t.redirectTo, jo(new w(4e3, ea)); o = o.children[L] } } applyRedirectCommands(t, n, r) { return this.applyRedirectCreateUrlTree(n, this.urlSerializer.parse(n), t, r) } applyRedirectCreateUrlTree(t, n, r, o) { const i = this.createSegmentGroup(t, n.root, r, o); return new Dn(i, this.createQueryParams(n.queryParams, this.urlTree.queryParams), n.fragment) } createQueryParams(t, n) { const r = {}; return Me(t, (o, i) => { if ("string" == typeof o && o.startsWith(":")) { const a = o.substring(1); r[i] = n[a] } else r[i] = o }), r } createSegmentGroup(t, n, r, o) { const i = this.createSegments(t, n.segments, r, o); let s = {}; return Me(n.children, (a, u) => { s[u] = this.createSegmentGroup(t, a, r, o) }), new U(i, s) } createSegments(t, n, r, o) { return n.map(i => i.path.startsWith(":") ? this.findPosParam(t, i, o) : this.findOrReturn(i, r)) } findPosParam(t, n, r) { const o = r[n.path.substring(1)]; if (!o) throw new w(4001, ea); return o } findOrReturn(t, n) { let r = 0; for (const o of n) { if (o.path === t.path) return n.splice(r), o; r++ } return t } } class fP { } class gP { constructor(t, n, r, o, i, s, a) { this.injector = t, this.rootComponentType = n, this.config = r, this.urlTree = o, this.url = i, this.paramsInheritanceStrategy = s, this.urlSerializer = a } recognize() { const t = Xs(this.urlTree.root, [], [], this.config.filter(n => void 0 === n.redirectTo)).segmentGroup; return this.processSegmentGroup(this.injector, this.config, t, L).pipe(H(n => { if (null === n) return null; const r = new Zs([], Object.freeze({}), Object.freeze({ ...this.urlTree.queryParams }), this.urlTree.fragment, {}, L, this.rootComponentType, null, this.urlTree.root, -1, {}), o = new on(r, n), i = new kv(this.url, o); return this.inheritParamsAndData(i._root), i })) } inheritParamsAndData(t) { const n = t.value, r = Fv(n, this.paramsInheritanceStrategy); n.params = Object.freeze(r.params), n.data = Object.freeze(r.data), t.children.forEach(o => this.inheritParamsAndData(o)) } processSegmentGroup(t, n, r, o) { return 0 === r.segments.length && r.hasChildren() ? this.processChildren(t, n, r) : this.processSegment(t, n, r, r.segments, o) } processChildren(t, n, r) { return ve(Object.keys(r.children)).pipe(Vn(o => { const i = r.children[o], s = Hv(n, o); return this.processSegmentGroup(t, s, i, o) }), cv((o, i) => o && i ? (o.push(...i), o) : null), function OR(e, t = !1) { return _e((n, r) => { let o = 0; n.subscribe(Ee(r, i => { const s = e(i, o++); (s || t) && r.next(i), !s && r.complete() })) }) }(o => null !== o), js(null), dv(), H(o => { if (null === o) return null; const i = Xv(o); return function mP(e) { e.sort((t, n) => t.value.outlet === L ? -1 : n.value.outlet === L ? 1 : t.value.outlet.localeCompare(n.value.outlet)) }(i), i })) } processSegment(t, n, r, o, i) { return ve(n).pipe(Vn(s => this.processSegmentAgainstRoute(s._injector ?? t, s, r, o, i)), mn(s => !!s), yn(s => { if (Vc(s)) return Zv(r, o, i) ? M([]) : M(null); throw s })) } processSegmentAgainstRoute(t, n, r, o, i) { if (n.redirectTo || !qv(n, r, o, i)) return M(null); let s; if ("**" === n.path) { const a = o.length > 0 ? pv(o).parameters : {}, u = eD(r) + o.length; s = M({ snapshot: new Zs(o, a, Object.freeze({ ...this.urlTree.queryParams }), this.urlTree.fragment, tD(n), ht(n), n.component ?? n._loadedComponent ?? null, n, Jv(r), u, nD(n)), consumedSegments: [], remainingSegments: [] }) } else s = Wv(r, n, o, t).pipe(H(({ matched: a, consumedSegments: u, remainingSegments: l, parameters: c }) => { if (!a) return null; const d = eD(r) + u.length; return { snapshot: new Zs(u, c, Object.freeze({ ...this.urlTree.queryParams }), this.urlTree.fragment, tD(n), ht(n), n.component ?? n._loadedComponent ?? null, n, Jv(r), d, nD(n)), consumedSegments: u, remainingSegments: l } })); return s.pipe(Lt(a => { if (null === a) return M(null); const { snapshot: u, consumedSegments: l, remainingSegments: c } = a; t = n._injector ?? t; const d = n._loadedInjector ?? t, f = function yP(e) { return e.children ? e.children : e.loadChildren ? e._loadedRoutes : [] }(n), { segmentGroup: h, slicedSegments: p } = Xs(r, l, c, f.filter(y => void 0 === y.redirectTo)); if (0 === p.length && h.hasChildren()) return this.processChildren(d, f, h).pipe(H(y => null === y ? null : [new on(u, y)])); if (0 === f.length && 0 === p.length) return M([new on(u, [])]); const g = ht(n) === i; return this.processSegment(d, f, h, p, g ? L : i).pipe(H(y => null === y ? null : [new on(u, y)])) })) } } function vP(e) { const t = e.value.routeConfig; return t && "" === t.path && void 0 === t.redirectTo } function Xv(e) { const t = [], n = new Set; for (const r of e) { if (!vP(r)) { t.push(r); continue } const o = t.find(i => r.value.routeConfig === i.value.routeConfig); void 0 !== o ? (o.children.push(...r.children), n.add(o)) : t.push(r) } for (const r of n) { const o = Xv(r.children); t.push(new on(r.value, o)) } return t.filter(r => !n.has(r)) } function Jv(e) { let t = e; for (; t._sourceSegment;)t = t._sourceSegment; return t } function eD(e) { let t = e, n = t._segmentIndexShift ?? 0; for (; t._sourceSegment;)t = t._sourceSegment, n += t._segmentIndexShift ?? 0; return n - 1 } function tD(e) { return e.data || {} } function nD(e) { return e.resolve || {} } function rD(e) { return "string" == typeof e.title || null === e.title } function Hc(e) { return Lt(t => { const n = e(t); return n ? ve(n).pipe(H(() => t)) : M(t) }) } const $r = new x("ROUTES"); let zc = (() => { class e { constructor() { this.componentLoaders = new WeakMap, this.childrenLoaders = new WeakMap, this.compiler = z(jm) } loadComponent(n) { if (this.componentLoaders.get(n)) return this.componentLoaders.get(n); if (n._loadedComponent) return M(n._loadedComponent); this.onLoadStartListener && this.onLoadStartListener(n); const r = vn(n.loadComponent()).pipe(H(iD), Fe(i => { this.onLoadEndListener && this.onLoadEndListener(n), n._loadedComponent = i }), Cc(() => { this.componentLoaders.delete(n) })), o = new uv(r, () => new Vt).pipe(Dc()); return this.componentLoaders.set(n, o), o } loadChildren(n, r) { if (this.childrenLoaders.get(r)) return this.childrenLoaders.get(r); if (r._loadedRoutes) return M({ routes: r._loadedRoutes, injector: r._loadedInjector }); this.onLoadStartListener && this.onLoadStartListener(r); const i = this.loadModuleFactoryOrRoutes(r.loadChildren).pipe(H(a => { this.onLoadEndListener && this.onLoadEndListener(r); let u, l, c = !1; Array.isArray(a) ? l = a : (u = a.create(n).injector, l = hv(u.get($r, [], A.Self | A.Optional))); return { routes: l.map($c), injector: u } }), Cc(() => { this.childrenLoaders.delete(r) })), s = new uv(i, () => new Vt).pipe(Dc()); return this.childrenLoaders.set(r, s), s } loadModuleFactoryOrRoutes(n) { return vn(n()).pipe(H(iD), be(r => r instanceof qg || Array.isArray(r) ? M(r) : ve(this.compiler.compileModuleAsync(r)))) } } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275prov = N({ token: e, factory: e.\u0275fac, providedIn: "root" }), e })(); function iD(e) { return function IP(e) { return e && "object" == typeof e && "default" in e }(e) ? e.default : e } let ra = (() => { class e { get hasRequestedNavigation() { return 0 !== this.navigationId } constructor() { this.currentNavigation = null, this.lastSuccessfulNavigation = null, this.events = new Vt, this.configLoader = z(zc), this.environmentInjector = z(Yt), this.urlSerializer = z(Uo), this.rootContexts = z(qo), this.navigationId = 0, this.afterPreactivation = () => M(void 0), this.rootComponentType = null, this.configLoader.onLoadEndListener = o => this.events.next(new hx(o)), this.configLoader.onLoadStartListener = o => this.events.next(new fx(o)) } complete() { this.transitions?.complete() } handleNavigationRequest(n) { const r = ++this.navigationId; this.transitions?.next({ ...this.transitions.value, ...n, id: r }) } setupNavigations(n) { return this.transitions = new St({ id: 0, targetPageId: 0, currentUrlTree: n.currentUrlTree, currentRawUrl: n.currentUrlTree, extractedUrl: n.urlHandlingStrategy.extract(n.currentUrlTree), urlAfterRedirects: n.urlHandlingStrategy.extract(n.currentUrlTree), rawUrl: n.currentUrlTree, extras: {}, resolve: null, reject: null, promise: Promise.resolve(!0), source: Go, restoredState: null, currentSnapshot: n.routerState.snapshot, targetSnapshot: null, currentRouterState: n.routerState, targetRouterState: null, guards: { canActivateChecks: [], canDeactivateChecks: [] }, guardsResult: null }), this.transitions.pipe(gn(r => 0 !== r.id), H(r => ({ ...r, extractedUrl: n.urlHandlingStrategy.extract(r.rawUrl) })), Lt(r => { let o = !1, i = !1; return M(r).pipe(Fe(s => { this.currentNavigation = { id: s.id, initialUrl: s.rawUrl, extractedUrl: s.extractedUrl, trigger: s.source, extras: s.extras, previousNavigation: this.lastSuccessfulNavigation ? { ...this.lastSuccessfulNavigation, previousNavigation: null } : null } }), Lt(s => { const a = n.browserUrlTree.toString(), u = !n.navigated || s.extractedUrl.toString() !== a || a !== n.currentUrlTree.toString(); if (!u && "reload" !== (s.extras.onSameUrlNavigation ?? n.onSameUrlNavigation)) { const c = ""; return this.events.next(new qs(s.id, n.serializeUrl(r.rawUrl), c, 0)), n.rawUrlTree = s.rawUrl, s.resolve(null), It } if (n.urlHandlingStrategy.shouldProcessUrl(s.rawUrl)) return sD(s.source) && (n.browserUrlTree = s.extractedUrl), M(s).pipe(Lt(c => { const d = this.transitions?.getValue(); return this.events.next(new Tc(c.id, this.urlSerializer.serialize(c.extractedUrl), c.source, c.restoredState)), d !== this.transitions?.getValue() ? It : Promise.resolve(c) }), function dP(e, t, n, r) { return Lt(o => function lP(e, t, n, r, o) { return new cP(e, t, n, r, o).apply() }(e, t, n, o.extractedUrl, r).pipe(H(i => ({ ...o, urlAfterRedirects: i })))) }(this.environmentInjector, this.configLoader, this.urlSerializer, n.config), Fe(c => { this.currentNavigation = { ...this.currentNavigation, finalUrl: c.urlAfterRedirects }, r.urlAfterRedirects = c.urlAfterRedirects }), function wP(e, t, n, r, o) { return be(i => function pP(e, t, n, r, o, i, s = "emptyOnly") { return new gP(e, t, n, r, o, s, i).recognize().pipe(Lt(a => null === a ? function hP(e) { return new ye(t => t.error(e)) }(new fP) : M(a))) }(e, t, n, i.urlAfterRedirects, r.serialize(i.urlAfterRedirects), r, o).pipe(H(s => ({ ...i, targetSnapshot: s })))) }(this.environmentInjector, this.rootComponentType, n.config, this.urlSerializer, n.paramsInheritanceStrategy), Fe(c => { if (r.targetSnapshot = c.targetSnapshot, "eager" === n.urlUpdateStrategy) { if (!c.extras.skipLocationChange) { const f = n.urlHandlingStrategy.merge(c.urlAfterRedirects, c.rawUrl); n.setBrowserUrl(f, c) } n.browserUrlTree = c.urlAfterRedirects } const d = new ax(c.id, this.urlSerializer.serialize(c.extractedUrl), this.urlSerializer.serialize(c.urlAfterRedirects), c.targetSnapshot); this.events.next(d) })); if (u && n.urlHandlingStrategy.shouldProcessUrl(n.rawUrlTree)) { const { id: c, extractedUrl: d, source: f, restoredState: h, extras: p } = s, g = new Tc(c, this.urlSerializer.serialize(d), f, h); this.events.next(g); const y = Ov(d, this.rootComponentType).snapshot; return M(r = { ...s, targetSnapshot: y, urlAfterRedirects: d, extras: { ...p, skipLocationChange: !1, replaceUrl: !1 } }) } { const c = ""; return this.events.next(new qs(s.id, n.serializeUrl(r.extractedUrl), c, 1)), n.rawUrlTree = s.rawUrl, s.resolve(null), It } }), Fe(s => { const a = new ux(s.id, this.urlSerializer.serialize(s.extractedUrl), this.urlSerializer.serialize(s.urlAfterRedirects), s.targetSnapshot); this.events.next(a) }), H(s => r = { ...s, guards: kx(s.targetSnapshot, s.currentSnapshot, this.rootContexts) }), function qx(e, t) { return be(n => { const { targetSnapshot: r, currentSnapshot: o, guards: { canActivateChecks: i, canDeactivateChecks: s } } = n; return 0 === s.length && 0 === i.length ? M({ ...n, guardsResult: !0 }) : function Zx(e, t, n, r) { return ve(e).pipe(be(o => function eP(e, t, n, r, o) { const i = t && t.routeConfig ? t.routeConfig.canDeactivate : null; return i && 0 !== i.length ? M(i.map(a => { const u = Zo(t) ?? o, l = Lr(a, u); return vn(function zx(e) { return e && Ko(e.canDeactivate) }(l) ? l.canDeactivate(e, t, n, r) : u.runInContext(() => l(e, t, n, r))).pipe(mn()) })).pipe(jr()) : M(!0) }(o.component, o.route, n, t, r)), mn(o => !0 !== o, !0)) }(s, r, o, e).pipe(be(a => a && function Vx(e) { return "boolean" == typeof e }(a) ? function Yx(e, t, n, r) { return ve(t).pipe(Vn(o => vc(function Kx(e, t) { return null !== e && t && t(new px(e)), M(!0) }(o.route.parent, r), function Qx(e, t) { return null !== e && t && t(new mx(e)), M(!0) }(o.route, r), function Jx(e, t, n) { const r = t[t.length - 1], i = t.slice(0, t.length - 1).reverse().map(s => function Lx(e) { const t = e.routeConfig ? e.routeConfig.canActivateChild : null; return t && 0 !== t.length ? { node: e, guards: t } : null }(s)).filter(s => null !== s).map(s => av(() => M(s.guards.map(u => { const l = Zo(s.node) ?? n, c = Lr(u, l); return vn(function Hx(e) { return e && Ko(e.canActivateChild) }(c) ? c.canActivateChild(r, e) : l.runInContext(() => c(r, e))).pipe(mn()) })).pipe(jr()))); return M(i).pipe(jr()) }(e, o.path, n), function Xx(e, t, n) { const r = t.routeConfig ? t.routeConfig.canActivate : null; if (!r || 0 === r.length) return M(!0); const o = r.map(i => av(() => { const s = Zo(t) ?? n, a = Lr(i, s); return vn(function Bx(e) { return e && Ko(e.canActivate) }(a) ? a.canActivate(t, e) : s.runInContext(() => a(t, e))).pipe(mn()) })); return M(o).pipe(jr()) }(e, o.route, n))), mn(o => !0 !== o, !0)) }(r, i, e, t) : M(a)), H(a => ({ ...n, guardsResult: a }))) }) }(this.environmentInjector, s => this.events.next(s)), Fe(s => { if (r.guardsResult = s.guardsResult, Bn(s.guardsResult)) throw jv(0, s.guardsResult); const a = new lx(s.id, this.urlSerializer.serialize(s.extractedUrl), this.urlSerializer.serialize(s.urlAfterRedirects), s.targetSnapshot, !!s.guardsResult); this.events.next(a) }), gn(s => !!s.guardsResult || (n.restoreHistory(s), this.cancelNavigationTransition(s, "", 3), !1)), Hc(s => { if (s.guards.canActivateChecks.length) return M(s).pipe(Fe(a => { const u = new cx(a.id, this.urlSerializer.serialize(a.extractedUrl), this.urlSerializer.serialize(a.urlAfterRedirects), a.targetSnapshot); this.events.next(u) }), Lt(a => { let u = !1; return M(a).pipe(function CP(e, t) { return be(n => { const { targetSnapshot: r, guards: { canActivateChecks: o } } = n; if (!o.length) return M(n); let i = 0; return ve(o).pipe(Vn(s => function _P(e, t, n, r) { const o = e.routeConfig, i = e._resolve; return void 0 !== o?.title && !rD(o) && (i[$o] = o.title), function EP(e, t, n, r) { const o = function bP(e) { return [...Object.keys(e), ...Object.getOwnPropertySymbols(e)] }(e); if (0 === o.length) return M({}); const i = {}; return ve(o).pipe(be(s => function SP(e, t, n, r) { const o = Zo(t) ?? r, i = Lr(e, o); return vn(i.resolve ? i.resolve(t, n) : o.runInContext(() => i(t, n))) }(e[s], t, n, r).pipe(mn(), Fe(a => { i[s] = a }))), wc(1), function FR(e) { return H(() => e) }(i), yn(s => Vc(s) ? It : jo(s))) }(i, e, t, r).pipe(H(s => (e._resolvedData = s, e.data = Fv(e, n).resolve, o && rD(o) && (e.data[$o] = o.title), null))) }(s.route, r, e, t)), Fe(() => i++), wc(1), be(s => i === o.length ? M(n) : It)) }) }(n.paramsInheritanceStrategy, this.environmentInjector), Fe({ next: () => u = !0, complete: () => { u || (n.restoreHistory(a), this.cancelNavigationTransition(a, "", 2)) } })) }), Fe(a => { const u = new dx(a.id, this.urlSerializer.serialize(a.extractedUrl), this.urlSerializer.serialize(a.urlAfterRedirects), a.targetSnapshot); this.events.next(u) })) }), Hc(s => { const a = u => { const l = []; u.routeConfig?.loadComponent && !u.routeConfig._loadedComponent && l.push(this.configLoader.loadComponent(u.routeConfig).pipe(Fe(c => { u.component = c }), H(() => { }))); for (const c of u.children) l.push(...a(c)); return l }; return iv(a(s.targetSnapshot.root)).pipe(js(), xr(1)) }), Hc(() => this.afterPreactivation()), H(s => { const a = function Sx(e, t, n) { const r = Wo(e, t._root, n ? n._root : void 0); return new Nv(r, t) }(n.routeReuseStrategy, s.targetSnapshot, s.currentRouterState); return r = { ...s, targetRouterState: a } }), Fe(s => { n.currentUrlTree = s.urlAfterRedirects, n.rawUrlTree = n.urlHandlingStrategy.merge(s.urlAfterRedirects, s.rawUrl), n.routerState = s.targetRouterState, "deferred" === n.urlUpdateStrategy && (s.extras.skipLocationChange || n.setBrowserUrl(n.rawUrlTree, s), n.browserUrlTree = s.urlAfterRedirects) }), ((e, t, n) => H(r => (new Fx(t, r.targetRouterState, r.currentRouterState, n).activate(e), r)))(this.rootContexts, n.routeReuseStrategy, s => this.events.next(s)), xr(1), Fe({ next: s => { o = !0, this.lastSuccessfulNavigation = this.currentNavigation, n.navigated = !0, this.events.next(new Hn(s.id, this.urlSerializer.serialize(s.extractedUrl), this.urlSerializer.serialize(n.currentUrlTree))), n.titleStrategy?.updateTitle(s.targetRouterState.snapshot), s.resolve(!0) }, complete: () => { o = !0 } }), Cc(() => { o || i || this.cancelNavigationTransition(r, "", 1), this.currentNavigation?.id === r.id && (this.currentNavigation = null) }), yn(s => { if (i = !0, Uv(s)) { Vv(s) || (n.navigated = !0, n.restoreHistory(r, !0)); const a = new Ws(r.id, this.urlSerializer.serialize(r.extractedUrl), s.message, s.cancellationCode); if (this.events.next(a), Vv(s)) { const u = n.urlHandlingStrategy.merge(s.url, n.rawUrlTree), l = { skipLocationChange: r.extras.skipLocationChange, replaceUrl: "eager" === n.urlUpdateStrategy || sD(r.source) }; n.scheduleNavigation(u, Go, null, l, { resolve: r.resolve, reject: r.reject, promise: r.promise }) } else r.resolve(!1) } else { n.restoreHistory(r, !0); const a = new Ac(r.id, this.urlSerializer.serialize(r.extractedUrl), s, r.targetSnapshot ?? void 0); this.events.next(a); try { r.resolve(n.errorHandler(s)) } catch (u) { r.reject(u) } } return It })) })) } cancelNavigationTransition(n, r, o) { const i = new Ws(n.id, this.urlSerializer.serialize(n.extractedUrl), r, o); this.events.next(i), n.resolve(!1) } } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275prov = N({ token: e, factory: e.\u0275fac, providedIn: "root" }), e })(); function sD(e) { return e !== Go } let aD = (() => { class e { buildTitle(n) { let r, o = n.root; for (; void 0 !== o;)r = this.getResolvedTitleForRoute(o) ?? r, o = o.children.find(i => i.outlet === L); return r } getResolvedTitleForRoute(n) { return n.data[$o] } } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275prov = N({ token: e, factory: function () { return z(MP) }, providedIn: "root" }), e })(), MP = (() => { class e extends aD { constructor(n) { super(), this.title = n } updateTitle(n) { const r = this.buildTitle(n); void 0 !== r && this.title.setTitle(r) } } return e.\u0275fac = function (n) { return new (n || e)(R(nv)) }, e.\u0275prov = N({ token: e, factory: e.\u0275fac, providedIn: "root" }), e })(), TP = (() => { class e { } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275prov = N({ token: e, factory: function () { return z(RP) }, providedIn: "root" }), e })(); class AP { shouldDetach(t) { return !1 } store(t, n) { } shouldAttach(t) { return !1 } retrieve(t) { return null } shouldReuseRoute(t, n) { return t.routeConfig === n.routeConfig } } let RP = (() => { class e extends AP { } return e.\u0275fac = function () { let t; return function (r) { return (t || (t = function vf(e) { return Bt(() => { const t = e.prototype.constructor, n = t[zt] || Wa(t), r = Object.prototype; let o = Object.getPrototypeOf(e.prototype).constructor; for (; o && o !== r;) { const i = o[zt] || Wa(o); if (i && i !== n) return i; o = Object.getPrototypeOf(o) } return i => new i }) }(e)))(r || e) } }(), e.\u0275prov = N({ token: e, factory: e.\u0275fac, providedIn: "root" }), e })(); const oa = new x("", { providedIn: "root", factory: () => ({}) }); let PP = (() => { class e { } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275prov = N({ token: e, factory: function () { return z(NP) }, providedIn: "root" }), e })(), NP = (() => { class e { shouldProcessUrl(n) { return !0 } extract(n) { return n } merge(n, r) { return n } } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275prov = N({ token: e, factory: e.\u0275fac, providedIn: "root" }), e })(); function OP(e) { throw e } function FP(e, t, n) { return t.parse("/") } const kP = { paths: "exact", fragment: "ignored", matrixParams: "ignored", queryParams: "exact" }, LP = { paths: "subset", fragment: "ignored", matrixParams: "ignored", queryParams: "subset" }; let Qe = (() => { class e { get navigationId() { return this.navigationTransitions.navigationId } get browserPageId() { if ("computed" === this.canceledNavigationResolution) return this.location.getState()?.\u0275routerPageId } get events() { return this.navigationTransitions.events } constructor() { this.disposed = !1, this.currentPageId = 0, this.console = z(iM), this.isNgZoneEnabled = !1, this.options = z(oa, { optional: !0 }) || {}, this.errorHandler = this.options.errorHandler || OP, this.malformedUriErrorHandler = this.options.malformedUriErrorHandler || FP, this.navigated = !1, this.lastSuccessfulId = -1, this.urlHandlingStrategy = z(PP), this.routeReuseStrategy = z(TP), this.urlCreationStrategy = z(_x), this.titleStrategy = z(aD), this.onSameUrlNavigation = this.options.onSameUrlNavigation || "ignore", this.paramsInheritanceStrategy = this.options.paramsInheritanceStrategy || "emptyOnly", this.urlUpdateStrategy = this.options.urlUpdateStrategy || "deferred", this.canceledNavigationResolution = this.options.canceledNavigationResolution || "replace", this.config = hv(z($r, { optional: !0 }) ?? []), this.navigationTransitions = z(ra), this.urlSerializer = z(Uo), this.location = z(ql), this.isNgZoneEnabled = z(ce) instanceof ce && ce.isInAngularZone(), this.resetConfig(this.config), this.currentUrlTree = new Dn, this.rawUrlTree = this.currentUrlTree, this.browserUrlTree = this.currentUrlTree, this.routerState = Ov(this.currentUrlTree, null), this.navigationTransitions.setupNavigations(this).subscribe(n => { this.lastSuccessfulId = n.id, this.currentPageId = this.browserPageId ?? 0 }, n => { this.console.warn(`Unhandled Navigation Error: ${n}`) }) } resetRootComponentType(n) { this.routerState.root.component = n, this.navigationTransitions.rootComponentType = n } initialNavigation() { if (this.setUpLocationChangeListener(), !this.navigationTransitions.hasRequestedNavigation) { const n = this.location.getState(); this.navigateToSyncWithBrowser(this.location.path(!0), Go, n) } } setUpLocationChangeListener() { this.locationSubscription || (this.locationSubscription = this.location.subscribe(n => { const r = "popstate" === n.type ? "popstate" : "hashchange"; "popstate" === r && setTimeout(() => { this.navigateToSyncWithBrowser(n.url, r, n.state) }, 0) })) } navigateToSyncWithBrowser(n, r, o) { const i = { replaceUrl: !0 }, s = o?.navigationId ? o : null; if (o) { const u = { ...o }; delete u.navigationId, delete u.\u0275routerPageId, 0 !== Object.keys(u).length && (i.state = u) } const a = this.parseUrl(n); this.scheduleNavigation(a, r, s, i) } get url() { return this.serializeUrl(this.currentUrlTree) } getCurrentNavigation() { return this.navigationTransitions.currentNavigation } resetConfig(n) { this.config = n.map($c), this.navigated = !1, this.lastSuccessfulId = -1 } ngOnDestroy() { this.dispose() } dispose() { this.navigationTransitions.complete(), this.locationSubscription && (this.locationSubscription.unsubscribe(), this.locationSubscription = void 0), this.disposed = !0 } createUrlTree(n, r = {}) { const { relativeTo: o, queryParams: i, fragment: s, queryParamsHandling: a, preserveFragment: u } = r, l = u ? this.currentUrlTree.fragment : s; let c = null; switch (a) { case "merge": c = { ...this.currentUrlTree.queryParams, ...i }; break; case "preserve": c = this.currentUrlTree.queryParams; break; default: c = i || null }return null !== c && (c = this.removeEmptyProps(c)), this.urlCreationStrategy.createUrlTree(o, this.routerState, this.currentUrlTree, n, c, l ?? null) } navigateByUrl(n, r = { skipLocationChange: !1 }) { const o = Bn(n) ? n : this.parseUrl(n), i = this.urlHandlingStrategy.merge(o, this.rawUrlTree); return this.scheduleNavigation(i, Go, null, r) } navigate(n, r = { skipLocationChange: !1 }) { return function jP(e) { for (let t = 0; t < e.length; t++) { const n = e[t]; if (null == n) throw new w(4008, false) } }(n), this.navigateByUrl(this.createUrlTree(n, r), r) } serializeUrl(n) { return this.urlSerializer.serialize(n) } parseUrl(n) { let r; try { r = this.urlSerializer.parse(n) } catch (o) { r = this.malformedUriErrorHandler(o, this.urlSerializer, n) } return r } isActive(n, r) { let o; if (o = !0 === r ? { ...kP } : !1 === r ? { ...LP } : r, Bn(n)) return mv(this.currentUrlTree, n, o); const i = this.parseUrl(n); return mv(this.currentUrlTree, i, o) } removeEmptyProps(n) { return Object.keys(n).reduce((r, o) => { const i = n[o]; return null != i && (r[o] = i), r }, {}) } scheduleNavigation(n, r, o, i, s) { if (this.disposed) return Promise.resolve(!1); let a, u, l, c; return s ? (a = s.resolve, u = s.reject, l = s.promise) : l = new Promise((d, f) => { a = d, u = f }), c = "computed" === this.canceledNavigationResolution ? o && o.\u0275routerPageId ? o.\u0275routerPageId : (this.browserPageId ?? 0) + 1 : 0, this.navigationTransitions.handleNavigationRequest({ targetPageId: c, source: r, restoredState: o, currentUrlTree: this.currentUrlTree, currentRawUrl: this.currentUrlTree, rawUrl: n, extras: i, resolve: a, reject: u, promise: l, currentSnapshot: this.routerState.snapshot, currentRouterState: this.routerState }), l.catch(d => Promise.reject(d)) } setBrowserUrl(n, r) { const o = this.urlSerializer.serialize(n); if (this.location.isCurrentPathEqualTo(o) || r.extras.replaceUrl) { const s = { ...r.extras.state, ...this.generateNgRouterState(r.id, this.browserPageId) }; this.location.replaceState(o, "", s) } else { const i = { ...r.extras.state, ...this.generateNgRouterState(r.id, r.targetPageId) }; this.location.go(o, "", i) } } restoreHistory(n, r = !1) { if ("computed" === this.canceledNavigationResolution) { const i = this.currentPageId - (this.browserPageId ?? this.currentPageId); 0 !== i ? this.location.historyGo(i) : this.currentUrlTree === this.getCurrentNavigation()?.finalUrl && 0 === i && (this.resetState(n), this.browserUrlTree = n.currentUrlTree, this.resetUrlToCurrentUrlTree()) } else "replace" === this.canceledNavigationResolution && (r && this.resetState(n), this.resetUrlToCurrentUrlTree()) } resetState(n) { this.routerState = n.currentRouterState, this.currentUrlTree = n.currentUrlTree, this.rawUrlTree = this.urlHandlingStrategy.merge(this.currentUrlTree, n.rawUrl) } resetUrlToCurrentUrlTree() { this.location.replaceState(this.urlSerializer.serialize(this.rawUrlTree), "", this.generateNgRouterState(this.lastSuccessfulId, this.currentPageId)) } generateNgRouterState(n, r) { return "computed" === this.canceledNavigationResolution ? { navigationId: n, \u0275routerPageId: r } : { navigationId: n } } } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275prov = N({ token: e, factory: e.\u0275fac, providedIn: "root" }), e })(), Jo = (() => { class e { constructor(n, r, o, i, s, a) { this.router = n, this.route = r, this.tabIndexAttribute = o, this.renderer = i, this.el = s, this.locationStrategy = a, this._preserveFragment = !1, this._skipLocationChange = !1, this._replaceUrl = !1, this.href = null, this.commands = null, this.onChanges = new Vt; const u = s.nativeElement.tagName?.toLowerCase(); this.isAnchorElement = "a" === u || "area" === u, this.isAnchorElement ? this.subscription = n.events.subscribe(l => { l instanceof Hn && this.updateHref() }) : this.setTabIndexIfNotOnNativeEl("0") } set preserveFragment(n) { this._preserveFragment = Hl(n) } get preserveFragment() { return this._preserveFragment } set skipLocationChange(n) { this._skipLocationChange = Hl(n) } get skipLocationChange() { return this._skipLocationChange } set replaceUrl(n) { this._replaceUrl = Hl(n) } get replaceUrl() { return this._replaceUrl } setTabIndexIfNotOnNativeEl(n) { null != this.tabIndexAttribute || this.isAnchorElement || this.applyAttributeValue("tabindex", n) } ngOnChanges(n) { this.isAnchorElement && this.updateHref(), this.onChanges.next(this) } set routerLink(n) { null != n ? (this.commands = Array.isArray(n) ? n : [n], this.setTabIndexIfNotOnNativeEl("0")) : (this.commands = null, this.setTabIndexIfNotOnNativeEl(null)) } onClick(n, r, o, i, s) { return !!(null === this.urlTree || this.isAnchorElement && (0 !== n || r || o || i || s || "string" == typeof this.target && "_self" != this.target)) || (this.router.navigateByUrl(this.urlTree, { skipLocationChange: this.skipLocationChange, replaceUrl: this.replaceUrl, state: this.state }), !this.isAnchorElement) } ngOnDestroy() { this.subscription?.unsubscribe() } updateHref() { this.href = null !== this.urlTree && this.locationStrategy ? this.locationStrategy?.prepareExternalUrl(this.router.serializeUrl(this.urlTree)) : null; const n = null === this.href ? null : function mh(e, t, n) { return function eE(e, t) { return "src" === t && ("embed" === e || "frame" === e || "iframe" === e || "media" === e || "script" === e) || "href" === t && ("base" === e || "link" === e) ? gh : $i }(t, n)(e) }(this.href, this.el.nativeElement.tagName.toLowerCase(), "href"); this.applyAttributeValue("href", n) } applyAttributeValue(n, r) { const o = this.renderer, i = this.el.nativeElement; null !== r ? o.setAttribute(i, n, r) : o.removeAttribute(i, n) } get urlTree() { return null === this.commands ? null : this.router.createUrlTree(this.commands, { relativeTo: void 0 !== this.relativeTo ? this.relativeTo : this.route, queryParams: this.queryParams, fragment: this.fragment, queryParamsHandling: this.queryParamsHandling, preserveFragment: this.preserveFragment }) } } return e.\u0275fac = function (n) { return new (n || e)(S(Qe), S(zn), function Ti(e) { return function SC(e, t) { if ("class" === t) return e.classes; if ("style" === t) return e.styles; const n = e.attrs; if (n) { const r = n.length; let o = 0; for (; o < r;) { const i = n[o]; if (rf(i)) break; if (0 === i) o += 2; else if ("number" == typeof i) for (o++; o < r && "string" == typeof n[o];)o++; else { if (i === t) return n[o + 1]; o += 2 } } } return null }(Ie(), e) }("tabindex"), S(Hi), S(dn), S($n)) }, e.\u0275dir = ke({ type: e, selectors: [["", "routerLink", ""]], hostVars: 1, hostBindings: function (n, r) { 1 & n && On("click", function (i) { return r.onClick(i.button, i.ctrlKey, i.shiftKey, i.altKey, i.metaKey) }), 2 & n && Ku("target", r.target) }, inputs: { target: "target", queryParams: "queryParams", fragment: "fragment", queryParamsHandling: "queryParamsHandling", state: "state", relativeTo: "relativeTo", preserveFragment: "preserveFragment", skipLocationChange: "skipLocationChange", replaceUrl: "replaceUrl", routerLink: "routerLink" }, standalone: !0, features: [Mn] }), e })(); class uD { } let UP = (() => { class e { constructor(n, r, o, i, s) { this.router = n, this.injector = o, this.preloadingStrategy = i, this.loader = s } setUpPreloading() { this.subscription = this.router.events.pipe(gn(n => n instanceof Hn), Vn(() => this.preload())).subscribe(() => { }) } preload() { return this.processRoutes(this.injector, this.router.config) } ngOnDestroy() { this.subscription && this.subscription.unsubscribe() } processRoutes(n, r) { const o = []; for (const i of r) { i.providers && !i._injector && (i._injector = cs(i.providers, n, `Route: ${i.path}`)); const s = i._injector ?? n, a = i._loadedInjector ?? s; (i.loadChildren && !i._loadedRoutes && void 0 === i.canLoad || i.loadComponent && !i._loadedComponent) && o.push(this.preloadConfig(s, i)), (i.children || i._loadedRoutes) && o.push(this.processRoutes(a, i.children ?? i._loadedRoutes)) } return ve(o).pipe(Gn()) } preloadConfig(n, r) { return this.preloadingStrategy.preload(r, () => { let o; o = r.loadChildren && void 0 === r.canLoad ? this.loader.loadChildren(n, r) : M(null); const i = o.pipe(be(s => null === s ? M(void 0) : (r._loadedRoutes = s.routes, r._loadedInjector = s.injector, this.processRoutes(s.injector ?? n, s.routes)))); return r.loadComponent && !r._loadedComponent ? ve([i, this.loader.loadComponent(r)]).pipe(Gn()) : i }) } } return e.\u0275fac = function (n) { return new (n || e)(R(Qe), R(jm), R(Yt), R(uD), R(zc)) }, e.\u0275prov = N({ token: e, factory: e.\u0275fac, providedIn: "root" }), e })(); const Wc = new x(""); let lD = (() => { class e { constructor(n, r, o, i, s = {}) { this.urlSerializer = n, this.transitions = r, this.viewportScroller = o, this.zone = i, this.options = s, this.lastId = 0, this.lastSource = "imperative", this.restoredId = 0, this.store = {}, s.scrollPositionRestoration = s.scrollPositionRestoration || "disabled", s.anchorScrolling = s.anchorScrolling || "disabled" } init() { "disabled" !== this.options.scrollPositionRestoration && this.viewportScroller.setHistoryScrollRestoration("manual"), this.routerEventsSubscription = this.createScrollEvents(), this.scrollEventsSubscription = this.consumeScrollEvents() } createScrollEvents() { return this.transitions.events.subscribe(n => { n instanceof Tc ? (this.store[this.lastId] = this.viewportScroller.getScrollPosition(), this.lastSource = n.navigationTrigger, this.restoredId = n.restoredState ? n.restoredState.navigationId : 0) : n instanceof Hn && (this.lastId = n.id, this.scheduleScrollEvent(n, this.urlSerializer.parse(n.urlAfterRedirects).fragment)) }) } consumeScrollEvents() { return this.transitions.events.subscribe(n => { n instanceof xv && (n.position ? "top" === this.options.scrollPositionRestoration ? this.viewportScroller.scrollToPosition([0, 0]) : "enabled" === this.options.scrollPositionRestoration && this.viewportScroller.scrollToPosition(n.position) : n.anchor && "enabled" === this.options.anchorScrolling ? this.viewportScroller.scrollToAnchor(n.anchor) : "disabled" !== this.options.scrollPositionRestoration && this.viewportScroller.scrollToPosition([0, 0])) }) } scheduleScrollEvent(n, r) { this.zone.runOutsideAngular(() => { setTimeout(() => { this.zone.run(() => { this.transitions.events.next(new xv(n, "popstate" === this.lastSource ? this.store[this.restoredId] : null, r)) }) }, 0) }) } ngOnDestroy() { this.routerEventsSubscription?.unsubscribe(), this.scrollEventsSubscription?.unsubscribe() } } return e.\u0275fac = function (n) { !function qh() { throw new Error("invalid") }() }, e.\u0275prov = N({ token: e, factory: e.\u0275fac }), e })(); var ot = (() => ((ot = ot || {})[ot.COMPLETE = 0] = "COMPLETE", ot[ot.FAILED = 1] = "FAILED", ot[ot.REDIRECTING = 2] = "REDIRECTING", ot))(); const Vr = !1; function wn(e, t) { return { \u0275kind: e, \u0275providers: t } } const qc = new x("", { providedIn: "root", factory: () => !1 }); function dD() { const e = z(Kt); return t => { const n = e.get(vs); if (t !== n.components[0]) return; const r = e.get(Qe), o = e.get(fD); 1 === e.get(Zc) && r.initialNavigation(), e.get(hD, null, A.Optional)?.setUpPreloading(), e.get(Wc, null, A.Optional)?.init(), r.resetRootComponentType(n.componentTypes[0]), o.closed || (o.next(), o.complete(), o.unsubscribe()) } } const fD = new x(Vr ? "bootstrap done indicator" : "", { factory: () => new Vt }), Zc = new x(Vr ? "initial navigation" : "", { providedIn: "root", factory: () => 1 }); function WP() { let e = []; return e = Vr ? [{ provide: Vi, multi: !0, useFactory: () => { const t = z(Qe); return () => t.events.subscribe(n => { console.group?.(`Router Event: ${n.constructor.name}`), console.log(function vx(e) { if (!("type" in e)) return `Unknown Router Event: ${e.constructor.name}`; switch (e.type) { case 14: return `ActivationEnd(path: '${e.snapshot.routeConfig?.path || ""}')`; case 13: return `ActivationStart(path: '${e.snapshot.routeConfig?.path || ""}')`; case 12: return `ChildActivationEnd(path: '${e.snapshot.routeConfig?.path || ""}')`; case 11: return `ChildActivationStart(path: '${e.snapshot.routeConfig?.path || ""}')`; case 8: return `GuardsCheckEnd(id: ${e.id}, url: '${e.url}', urlAfterRedirects: '${e.urlAfterRedirects}', state: ${e.state}, shouldActivate: ${e.shouldActivate})`; case 7: return `GuardsCheckStart(id: ${e.id}, url: '${e.url}', urlAfterRedirects: '${e.urlAfterRedirects}', state: ${e.state})`; case 2: return `NavigationCancel(id: ${e.id}, url: '${e.url}')`; case 16: return `NavigationSkipped(id: ${e.id}, url: '${e.url}')`; case 1: return `NavigationEnd(id: ${e.id}, url: '${e.url}', urlAfterRedirects: '${e.urlAfterRedirects}')`; case 3: return `NavigationError(id: ${e.id}, url: '${e.url}', error: ${e.error})`; case 0: return `NavigationStart(id: ${e.id}, url: '${e.url}')`; case 6: return `ResolveEnd(id: ${e.id}, url: '${e.url}', urlAfterRedirects: '${e.urlAfterRedirects}', state: ${e.state})`; case 5: return `ResolveStart(id: ${e.id}, url: '${e.url}', urlAfterRedirects: '${e.urlAfterRedirects}', state: ${e.state})`; case 10: return `RouteConfigLoadEnd(path: ${e.route.path})`; case 9: return `RouteConfigLoadStart(path: ${e.route.path})`; case 4: return `RoutesRecognized(id: ${e.id}, url: '${e.url}', urlAfterRedirects: '${e.urlAfterRedirects}', state: ${e.state})`; case 15: return `Scroll(anchor: '${e.anchor}', position: '${e.position ? `${e.position[0]}, ${e.position[1]}` : null}')` } }(n)), console.log(n), console.groupEnd?.() }) } }] : [], wn(1, e) } const hD = new x(Vr ? "router preloader" : ""); function qP(e) { return wn(0, [{ provide: hD, useExisting: UP }, { provide: uD, useExisting: e }]) } const ei = !1, pD = new x(ei ? "router duplicate forRoot guard" : "ROUTER_FORROOT_GUARD"), ZP = [ql, { provide: Uo, useClass: _c }, Qe, qo, { provide: zn, useFactory: function cD(e) { return e.routerState.root }, deps: [Qe] }, zc, ei ? { provide: qc, useValue: !0 } : []]; function YP() { return new Wm("Router", Qe) } let gD = (() => { class e { constructor(n) { } static forRoot(n, r) { return { ngModule: e, providers: [ZP, ei && r?.enableTracing ? WP().\u0275providers : [], { provide: $r, multi: !0, useValue: n }, { provide: pD, useFactory: JP, deps: [[Qe, new so, new ao]] }, { provide: oa, useValue: r || {} }, r?.useHash ? { provide: $n, useClass: WM } : { provide: $n, useClass: gy }, { provide: Wc, useFactory: () => { const e = z(hA), t = z(ce), n = z(oa), r = z(ra), o = z(Uo); return n.scrollOffset && e.setOffset(n.scrollOffset), new lD(o, r, e, t, n) } }, r?.preloadingStrategy ? qP(r.preloadingStrategy).\u0275providers : [], { provide: Wm, multi: !0, useFactory: YP }, r?.initialNavigation ? eN(r) : [], [{ provide: mD, useFactory: dD }, { provide: Gm, multi: !0, useExisting: mD }]] } } static forChild(n) { return { ngModule: e, providers: [{ provide: $r, multi: !0, useValue: n }] } } } return e.\u0275fac = function (n) { return new (n || e)(R(pD, 8)) }, e.\u0275mod = bn({ type: e }), e.\u0275inj = un({ imports: [Lc] }), e })(); function JP(e) { if (ei && e) throw new w(4007, "The Router was provided more than once. This can happen if 'forRoot' is used outside of the root injector. Lazy loaded modules should use RouterModule.forChild() instead."); return "guarded" } function eN(e) { return ["disabled" === e.initialNavigation ? wn(3, [{ provide: gs, multi: !0, useFactory: () => { const t = z(Qe); return () => { t.setUpLocationChangeListener() } } }, { provide: Zc, useValue: 2 }]).\u0275providers : [], "enabledBlocking" === e.initialNavigation ? wn(2, [{ provide: Zc, useValue: 0 }, { provide: gs, multi: !0, deps: [Kt], useFactory: t => { const n = t.get(zM, Promise.resolve()); return () => n.then(() => new Promise(r => { const o = t.get(Qe), i = t.get(fD); (function BP(e, t) { e.events.pipe(gn(n => n instanceof Hn || n instanceof Ws || n instanceof Ac || n instanceof qs), H(n => n instanceof Hn || n instanceof qs ? ot.COMPLETE : n instanceof Ws && (0 === n.code || 1 === n.code) ? ot.REDIRECTING : ot.FAILED), gn(n => n !== ot.REDIRECTING), xr(1)).subscribe(() => { t() }) })(o, () => { r(!0) }), t.get(ra).afterPreactivation = () => (r(!0), i.closed ? M(void 0) : i), o.initialNavigation() })) } }]).\u0275providers : []] } const mD = new x(ei ? "Router Initializer" : ""), nN = function () { return ["/battle", "paper"] }, rN = function () { return ["/battle", "scissors"] }, oN = function () { return ["/battle", "rock"] }; let iN = (() => { class e { static #e = this.\u0275fac = function (r) { return new (r || e) }; static #t = this.\u0275cmp = Yr({ type: e, selectors: [["app-yourturn"]], decls: 10, vars: 6, consts: [[1, "d-flex", "justify-content-center", "align-items-center", "mt-4", "mt-md-5"], [1, "game"], ["src", "./assets/images/bg-triangle.svg", "alt", "bg-triangle", 1, "triangle"], [1, "choices"], [1, "choice", "paper", 3, "routerLink"], ["src", "./assets/images/icon-paper.svg", "alt", "icon-paper"], [1, "choice", "scissors", 3, "routerLink"], ["src", "./assets/images/icon-scissors.svg", "alt", "icon-scissors"], [1, "choice", "rock", 3, "routerLink"], ["src", "./assets/images/icon-rock.svg", "alt", "icon-rock"]], template: function (r, o) { 1 & r && (re(0, "main", 0)(1, "div", 1), Ne(2, "img", 2), re(3, "div", 3)(4, "div", 4), Ne(5, "img", 5), ie(), re(6, "div", 6), Ne(7, "img", 7), ie(), re(8, "div", 8), Ne(9, "img", 9), ie()()()()), 2 & r && (Ve(4), rt("routerLink", ds(3, nN)), Ve(2), rt("routerLink", ds(4, rN)), Ve(2), rt("routerLink", ds(5, oN))) }, dependencies: [Jo], styles: [".game[_ngcontent-%COMP%]{position:relative}.game[_ngcontent-%COMP%]   .triangle[_ngcontent-%COMP%]{position:relative;z-index:-2}@media (min-width: 767px){.game[_ngcontent-%COMP%]   .triangle[_ngcontent-%COMP%]{width:400px}}.choice[_ngcontent-%COMP%]{position:absolute;transition:all .5s}.choice[_ngcontent-%COMP%]:hover{transform:scale(1.2)}.choices[_ngcontent-%COMP%]   .paper[_ngcontent-%COMP%]{top:-60px;left:-20px}.choices[_ngcontent-%COMP%]   .scissors[_ngcontent-%COMP%]{top:-60px;right:-20px}.choices[_ngcontent-%COMP%]   .rock[_ngcontent-%COMP%]{bottom:-60px;left:32%}"] }) } return e })(); const sN = function (e) { return { winner: e } }, aN = function (e) { return { hide: e } }; let yD = (() => { class e { constructor(n, r) { this.route = n, this.router = r, this.nbr = 0, this.play = !1, this.result = "", this.score = new Oe, this.paper = { title: "paper", imgSource: "./assets/images/icon-paper.svg", alt: "icon-paper" }, this.rock = { title: "rock", imgSource: "./assets/images/icon-rock.svg", alt: "icon-rock" }, this.scissors = { title: "scissors", imgSource: "./assets/images/icon-scissors.svg", alt: "icon-scissors" }, this.chosen = this.rock, this.show = setTimeout(() => { this.play = !0, this.chosen = 1 == this.nbr ? this.paper : 2 == this.nbr ? this.rock : this.scissors, this.game(this.userChoice) }, 3e3) } ngOnInit() { this.userChoice = this.route.snapshot.paramMap.get("yours"), this.nbr = this.getRandomInt(3) } getRandomInt(n) { return Math.ceil(Math.random() * n) } game(n) { "rock" === n && "scissors" === this.chosen.title || "paper" === n && "rock" === this.chosen.title || "scissors" === n && "paper" === this.chosen.title ? (this.winners = "you", this.score.emit(1), this.result = "You Win") : "scissors" === n && "rock" === this.chosen.title || "rock" === n && "paper" === this.chosen.title || "paper" === n && "scissors" === this.chosen.title ? (this.winners = "computer", this.score.emit(-1), this.result = "You Lose") : this.result = "Draw" } static #e = this.\u0275fac = function (r) { return new (r || e)(S(zn), S(Qe)) }; static #t = this.\u0275cmp = Yr({ type: e, selectors: [["app-battlefield"]], outputs: { score: "score" }, decls: 27, vars: 18, consts: [[1, "d-flex", "flex-column", "justify-content-center", "align-items-center", "mt-4", "mt-md-5", "mb-3"], [1, "battle", "d-flex", "gap-3", "justify-content-around", "align-items-center"], [1, "you-picked", "col-6"], [1, "text-uppercase", "fw-bold"], [1, "your-choice"], [3, "ngClass"], ["alt", "icon-paper", 3, "src"], [1, "house-picked", "col-6"], [1, "house-choice"], [1, "choice", "paper", "paper-choix"], ["src", "./assets/images/icon-paper.svg", "alt", "icon-paper"], [1, "choice", "rock", "rock-choix"], ["src", "./assets/images/icon-rock.svg", "alt", "icon-rock"], [1, "choice", "scissors", "scissors-choix"], ["src", "./assets/images/icon-scissors.svg", "alt", "icon-scissors"], [3, "src", "alt"], [1, "text-center", "text-uppercase", "rslt", "mt-5", 3, "ngClass"], [3, "routerLink"]], template: function (r, o) { 1 & r && (re(0, "main", 0)(1, "div", 1)(2, "div", 2)(3, "h3", 3), kt(4, " you picked"), ie(), re(5, "div", 4)(6, "div", 5), Ne(7, "img", 6), ie()()(), re(8, "div", 7)(9, "h3", 3), kt(10, " The house picked"), ie(), re(11, "div", 8)(12, "div", 5)(13, "div", 9), Ne(14, "img", 10), ie(), re(15, "div", 11), Ne(16, "img", 12), ie(), re(17, "div", 13), Ne(18, "img", 14), ie()(), re(19, "div", 5)(20, "div", 5), Ne(21, "img", 15), ie()()()()(), re(22, "div", 16)(23, "h2"), kt(24), ie(), re(25, "a", 17), kt(26, "Play again"), ie()()()), 2 & r && (Ve(6), rs("choice " + o.userChoice), rt("ngClass", "you" === o.winners ? "winner" : ""), Ve(1), rt("src", "./assets/images/icon-" + o.userChoice + ".svg", $i), Ve(5), rt("ngClass", o.play ? "hide" : "show"), Ve(7), rt("ngClass", o.play ? "show" : "hide"), Ve(1), rs(o.chosen.title + " choice"), rt("ngClass", gl(14, sN, "computer" === o.winners)), Ve(1), rt("src", o.chosen.imgSource, $i)("alt", o.chosen.alt), Ve(1), rt("ngClass", gl(16, aN, "" === o.result)), Ve(2), is(o.result), Ve(1), rt("routerLink", "")) }, dependencies: [Iy, Jo], styles: [".battle[_ngcontent-%COMP%]{width:100%}.choice[_ngcontent-%COMP%]{position:relative;transition:all .5s}.winner[_ngcontent-%COMP%]{transform:scale(1.2);border-radius:50%;animation:_ngcontent-%COMP%_boxanimation 2s ease-in-out infinite}@keyframes _ngcontent-%COMP%_boxanimation{0%{box-shadow:inset 0 -5px 1px #00000034,0 5px 17px #0000004b}33%{box-shadow:inset 0 -5px 1px #00000034,0 5px 17px #0000004b,0 0 0 30px #ffffff05}66%{box-shadow:inset 0 -5px 1px #00000034,0 5px 17px #0000004b,0 0 0 30px #ffffff05,0 0 0 60px #ffffff08}to{box-shadow:inset 0 -5px 1px #00000034,0 5px 10px #0000004b,0 0 0 30px #ffffff05,0 0 0 60px #ffffff08,0 0 0 90px #ffffff0a}}.rock-choix[_ngcontent-%COMP%]{animation:_ngcontent-%COMP%_rockdisplay .5s ease alternate infinite;position:absolute}.paper-choix[_ngcontent-%COMP%]{animation:_ngcontent-%COMP%_paperdisplay .5s ease alternate infinite;position:absolute}.scissors-choix[_ngcontent-%COMP%]{animation:_ngcontent-%COMP%_scissorsdisplay .5s ease alternate infinite}@keyframes _ngcontent-%COMP%_paperdisplay{0%{opacity:0}50%{opacity:0}to{opacity:1}}@keyframes _ngcontent-%COMP%_rockdisplay{0%{opacity:0}50%{opacity:1}to{opacity:0}}@keyframes _ngcontent-%COMP%_scissorsdisplay{0%{opacity:1}50%{opacity:0}to{opacity:0}}.rslt[_ngcontent-%COMP%]   h2[_ngcontent-%COMP%]{font-size:62px;font-weight:700;letter-spacing:1.5px}.rslt[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]{background-color:#fff;color:var(--Dark-Text);font-size:24px;padding:15px 60px;border-radius:5px;font-weight:600;cursor:pointer;box-shadow:0 0 21px 7px #ffffff1a;text-decoration:none}.rslt[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]:hover{color:#dc2e4e}.house-choice[_ngcontent-%COMP%], .your-choice[_ngcontent-%COMP%]{width:-moz-fit-content;width:fit-content}.house-picked[_ngcontent-%COMP%], .you-picked[_ngcontent-%COMP%]{display:flex;flex-direction:column;align-items:center;justify-content:center;gap:30px}"] }) } return e })(); const uN = [{ path: "", component: iN }, { path: "battle/:yours", component: yD }]; let lN = (() => { class e { static #e = this.\u0275fac = function (r) { return new (r || e) }; static #t = this.\u0275mod = bn({ type: e }); static #n = this.\u0275inj = un({ imports: [gD.forRoot(uN), gD] }) } return e })(), cN = (() => { class e { constructor() { this.score = 0, this.stat = "hide" } rest() { this.score = 0 } showRules() { this.stat = "show" } hideRules() { this.stat = "hide" } subscribeToEmiter(n) { n instanceof yD && n.score.subscribe(o => { this.score += o }) } unsubscribe() { this.subscription && this.subscription.unsubscribe() } static #e = this.\u0275fac = function (r) { return new (r || e) }; static #t = this.\u0275cmp = Yr({ type: e, selectors: [["app-root"]], decls: 23, vars: 3, consts: [[1, "container"], [1, "d-flex", "justify-content-between", "align-items-center", "p-4", "mt-4"], ["src", "./assets/images/logo.svg", "alt", "logo"], [1, "score", "text-center"], [3, "activate", "deactivate"], [1, "text-center", "text-sm-end", "pb-2"], [3, "click"], [1, "ml-2", 3, "click"], [1, "overlay"], [1, "img-show", "p-2"], [1, "d-flex", "justify-content-md-between", "justify-content-center", "align-items-center", "px-3"], [1, "text-uppercase", "text-center", "pt-4", "pt-md-2", "text-md-start", "pl-md-2"], ["src", "./assets/images/icon-close.svg", "alt", "icon-close"], ["src", "./assets/images/image-rules.svg", "alt", "image-rules"]], template: function (r, o) { 1 & r && (re(0, "div", 0)(1, "header", 1), Ne(2, "img", 2), re(3, "div", 3)(4, "h4"), kt(5, "Score"), ie(), re(6, "span"), kt(7), ie()()(), re(8, "router-outlet", 4), On("activate", function (s) { return o.subscribeToEmiter(s) })("deactivate", function () { return o.unsubscribe() }), ie(), re(9, "footer", 5)(10, "a", 6), On("click", function () { return o.showRules() }), kt(11, "Rules"), ie(), re(12, "a", 7), On("click", function () { return o.rest() }), kt(13, "Reset"), ie()()(), re(14, "div"), Ne(15, "div", 8), re(16, "div", 9)(17, "div", 10)(18, "h3", 11), kt(19, "Rules"), ie(), re(20, "span", 6), On("click", function () { return o.hideRules() }), Ne(21, "img", 12), ie()(), Ne(22, "img", 13), ie()()), 2 & r && (Ve(7), is(o.score), Ve(7), rs(o.stat)) }, dependencies: [kc], styles: ["*[_ngcontent-%COMP%]{color:#fff}header[_ngcontent-%COMP%]{border:3px solid var(--Header-Outline);border-radius:20px;text-transform:uppercase}.score[_ngcontent-%COMP%]{background-color:#fff;padding:15px clamp(30px,2vw,50px);border-radius:5px}.score[_ngcontent-%COMP%]   h4[_ngcontent-%COMP%]{letter-spacing:1px;color:var(--Score-Text);font-weight:600;margin:0;font-size:20px}.score[_ngcontent-%COMP%]   span[_ngcontent-%COMP%]{color:var(--Dark-Text);font-size:48px;font-weight:700}footer[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]{border:2px solid var(--Header-Outline);border-radius:10px;text-transform:uppercase;font-size:20px;padding:10px 30px;cursor:pointer;text-decoration:none;margin-left:5px}.show[_ngcontent-%COMP%]   .overlay[_ngcontent-%COMP%]{width:100%;height:100%;background:rgba(0,0,0,.66);position:absolute;top:0;left:0}.show[_ngcontent-%COMP%]   .img-show[_ngcontent-%COMP%]{width:680px;height:520px;background:#FFF;position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);overflow:hidden;border-radius:20px}.img-show[_ngcontent-%COMP%]   span[_ngcontent-%COMP%]{cursor:pointer}.img-show[_ngcontent-%COMP%]   h3[_ngcontent-%COMP%]{font-size:64px;color:var(--Dark-Text);font-weight:700}.img-show[_ngcontent-%COMP%] > img[_ngcontent-%COMP%]{width:75%;height:75%;position:absolute;top:55%;left:50%;transform:translate(-50%,-50%)}@media (max-width: 767px){.show[_ngcontent-%COMP%]   .img-show[_ngcontent-%COMP%]{width:100%;height:100%;border-radius:0}.img-show[_ngcontent-%COMP%] > img[_ngcontent-%COMP%]{height:50%}.img-show[_ngcontent-%COMP%]   span[_ngcontent-%COMP%]{position:absolute;top:85%;right:50%;transform:translate(50%)}.img-show[_ngcontent-%COMP%]   span[_ngcontent-%COMP%]   img[_ngcontent-%COMP%]{width:28px}}"] }) } return e })(), dN = (() => { class e { static #e = this.\u0275fac = function (r) { return new (r || e) }; static #t = this.\u0275mod = bn({ type: e, bootstrap: [cN] }); static #n = this.\u0275inj = un({ imports: [dR, lN] }) } return e })(); cR().bootstrapModule(dN).catch(e => console.error(e)) } }, X => { X(X.s = 54) }]);
